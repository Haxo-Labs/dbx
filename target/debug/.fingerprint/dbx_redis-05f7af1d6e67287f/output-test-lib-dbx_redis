{"$message_type":"diagnostic","message":"the name `RedisError` is defined multiple times","code":{"code":"E0255","explanation":"You can't import a value whose name is the same as another value defined in the\nmodule.\n\nErroneous code example:\n\n```compile_fail,E0255\nuse bar::foo; // error: an item named `foo` is already in scope\n\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {}\n```\n\nYou can use aliases in order to fix this error. Example:\n\n```\nuse bar::foo as bar_foo; // ok!\n\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {}\n```\n\nOr you can reference the item with its parent:\n\n```\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {\n    bar::foo(); // we get the item by referring to its parent\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":1088,"byte_end":1107,"line_start":41,"line_end":41,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"`RedisError` redefined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/lib.rs","byte_start":163,"byte_end":173,"line_start":13,"line_end":13,"column_start":18,"column_end":28,"is_primary":false,"text":[{"text":"pub use error::{ RedisError, RedisResult };","highlight_start":18,"highlight_end":28}],"label":"previous import of the type `RedisError` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`RedisError` must be defined only once in the type namespace of this module","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"you can use `as` to change the binding name of the import","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":173,"byte_end":173,"line_start":13,"line_end":13,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"pub use error::{ RedisError, RedisResult };","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":" as OtherRedisError","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0255]\u001b[0m\u001b[0m\u001b[1m: the name `RedisError` is defined multiple times\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:41:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub use error::{ RedisError, RedisResult };\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mprevious import of the type `RedisError` here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`RedisError` redefined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `RedisError` must be defined only once in the type namespace of this module\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can use `as` to change the binding name of the import\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub use error::{ RedisError\u001b[0m\u001b[0m\u001b[38;5;10m as OtherRedisError\u001b[0m\u001b[0m, RedisResult };\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `metadata::RedisMetadata`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":340,"byte_end":363,"line_start":18,"line_end":18,"column_start":9,"column_end":32,"is_primary":true,"text":[{"text":"pub use metadata::RedisMetadata;","highlight_start":9,"highlight_end":32}],"label":"no `RedisMetadata` in `metadata`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `metadata::RedisMetadata`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:18:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub use metadata::RedisMetadata;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `RedisMetadata` in `metadata`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `config` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/connection.rs","byte_start":167,"byte_end":173,"line_start":5,"line_end":5,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"use dbx_core::config::DbConfig;","highlight_start":15,"highlight_end":21}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `config` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":0,"byte_end":10,"line_start":1,"line_end":1,"column_start":1,"column_end":11,"is_primary":true,"text":[{"text":"mod config;","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `config` is private\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/connection.rs:5:15\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse dbx_core::config::DbConfig;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `config` is defined here\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:1:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod config;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `query` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/commands.rs","byte_start":178,"byte_end":183,"line_start":5,"line_end":5,"column_start":15,"column_end":20,"is_primary":true,"text":[{"text":"use dbx_core::query::{ QueryResult, QueryParam };","highlight_start":15,"highlight_end":20}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `query` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":37,"byte_end":46,"line_start":4,"line_end":4,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"mod query;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `query` is private\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/commands.rs:5:15\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse dbx_core::query::{ QueryResult, QueryParam };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `query` is defined here\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:4:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod query;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `query` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/transaction.rs","byte_start":155,"byte_end":160,"line_start":4,"line_end":4,"column_start":15,"column_end":20,"is_primary":true,"text":[{"text":"use dbx_core::query::{ QueryResult, QueryParam };","highlight_start":15,"highlight_end":20}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `query` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":37,"byte_end":46,"line_start":4,"line_end":4,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"mod query;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `query` is private\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/transaction.rs:4:15\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse dbx_core::query::{ QueryResult, QueryParam };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `query` is defined here\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:4:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod query;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `query` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":132,"byte_end":137,"line_start":4,"line_end":4,"column_start":15,"column_end":20,"is_primary":true,"text":[{"text":"use dbx_core::query::{ PreparedQuery, QueryParam, QueryResult };","highlight_start":15,"highlight_end":20}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `query` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":37,"byte_end":46,"line_start":4,"line_end":4,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"mod query;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `query` is private\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:4:15\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse dbx_core::query::{ PreparedQuery, QueryParam, QueryResult };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `query` is defined here\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:4:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod query;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `config` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":612,"byte_end":618,"line_start":27,"line_end":27,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    config::DbConfig,","highlight_start":5,"highlight_end":11}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `config` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":0,"byte_end":10,"line_start":1,"line_end":1,"column_start":1,"column_end":11,"is_primary":true,"text":[{"text":"mod config;","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `config` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:27:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    config::DbConfig,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `config` is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:1:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod config;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `error` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":634,"byte_end":639,"line_start":28,"line_end":28,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    error::{ DbError, DbResult },","highlight_start":5,"highlight_end":10}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/lib.rs","byte_start":643,"byte_end":650,"line_start":28,"line_end":28,"column_start":14,"column_end":21,"is_primary":false,"text":[{"text":"    error::{ DbError, DbResult },","highlight_start":14,"highlight_end":21}],"label":"enum `DbError` is not publicly re-exported","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `error` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":12,"byte_end":21,"line_start":2,"line_end":2,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"mod error;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `error` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:28:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    error::{ DbError, DbResult },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12menum `DbError` is not publicly re-exported\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `error` is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:2:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod error;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `error` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":634,"byte_end":639,"line_start":28,"line_end":28,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    error::{ DbError, DbResult },","highlight_start":5,"highlight_end":10}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `error` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":12,"byte_end":21,"line_start":2,"line_end":2,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"mod error;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `error` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:28:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    error::{ DbError, DbResult },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `error` is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:2:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod error;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `metadata` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":668,"byte_end":676,"line_start":29,"line_end":29,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    metadata::{ DatabaseMetadata, TableMetadata, ColumnMetadata },","highlight_start":5,"highlight_end":13}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `metadata` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":23,"byte_end":35,"line_start":3,"line_end":3,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"mod metadata;","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `metadata` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:29:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    metadata::{ DatabaseMetadata, TableMetadata, ColumnMetadata },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `metadata` is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:3:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod metadata;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `query` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":735,"byte_end":740,"line_start":30,"line_end":30,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    query::{ QueryResult, PreparedQuery, QueryParam },","highlight_start":5,"highlight_end":10}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `query` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":37,"byte_end":46,"line_start":4,"line_end":4,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"mod query;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `query` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:30:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    query::{ QueryResult, PreparedQuery, QueryParam },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `query` is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:4:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod query;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `traits` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":790,"byte_end":796,"line_start":31,"line_end":31,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },","highlight_start":5,"highlight_end":11}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/lib.rs","byte_start":800,"byte_end":811,"line_start":31,"line_end":31,"column_start":15,"column_end":26,"is_primary":false,"text":[{"text":"    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },","highlight_start":15,"highlight_end":26}],"label":"trait `DbxDatabase` is not publicly re-exported","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the module `traits` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":48,"byte_end":58,"line_start":5,"line_end":5,"column_start":1,"column_end":11,"is_primary":true,"text":[{"text":"mod traits;","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `traits` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:31:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtrait `DbxDatabase` is not publicly re-exported\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `traits` is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:5:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod traits;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `traits` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":790,"byte_end":796,"line_start":31,"line_end":31,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },","highlight_start":5,"highlight_end":11}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this trait instead:\ndbx_core::PreparedStatementSupport","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":813,"byte_end":837,"line_start":31,"line_end":31,"column_start":28,"column_end":52,"is_primary":true,"text":[{"text":"    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },","highlight_start":28,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the module `traits` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":48,"byte_end":58,"line_start":5,"line_end":5,"column_start":1,"column_end":11,"is_primary":true,"text":[{"text":"mod traits;","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `traits` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:31:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this trait instead:\u001b[0m\n\u001b[0m      dbx_core::PreparedStatementSupport\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:31:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `traits` is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:5:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod traits;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `traits` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":790,"byte_end":796,"line_start":31,"line_end":31,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },","highlight_start":5,"highlight_end":11}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this trait instead:\ndbx_core::TransactionSupport","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":839,"byte_end":857,"line_start":31,"line_end":31,"column_start":54,"column_end":72,"is_primary":true,"text":[{"text":"    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },","highlight_start":54,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the module `traits` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":48,"byte_end":58,"line_start":5,"line_end":5,"column_start":1,"column_end":11,"is_primary":true,"text":[{"text":"mod traits;","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `traits` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:31:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this trait instead:\u001b[0m\n\u001b[0m      dbx_core::TransactionSupport\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:31:54\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `traits` is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:5:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod traits;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"module `traits` is private","code":{"code":"E0603","explanation":"A private item was used outside its scope.\n\nErroneous code example:\n\n```compile_fail,E0603\nmod foo {\n    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n                                            // can't use it outside of the\n                                            // `foo` module.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // error: constant `PRIVATE`\n                                                  //        is private\n```\n\nIn order to fix this error, you need to make the item public by using the `pub`\nkeyword. Example:\n\n```\nmod foo {\n    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n                                                // `pub` keyword.\n}\n\nprintln!(\"const value: {}\", foo::PRIVATE); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":790,"byte_end":796,"line_start":31,"line_end":31,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },","highlight_start":5,"highlight_end":11}],"label":"private module","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this trait instead:\ndbx_core::ConnectionPoolSupport","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":859,"byte_end":880,"line_start":31,"line_end":31,"column_start":74,"column_end":95,"is_primary":true,"text":[{"text":"    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },","highlight_start":74,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the module `traits` is defined here","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs","byte_start":48,"byte_end":58,"line_start":5,"line_end":5,"column_start":1,"column_end":11,"is_primary":true,"text":[{"text":"mod traits;","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0603]\u001b[0m\u001b[0m\u001b[1m: module `traits` is private\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:31:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mprivate module\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this trait instead:\u001b[0m\n\u001b[0m      dbx_core::ConnectionPoolSupport\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:31:74\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    traits::{ DbxDatabase, PreparedStatementSupport, TransactionSupport, ConnectionPoolSupport },\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the module `traits` is defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/Projects/effortlesslabs/dbx/crates/core/src/lib.rs:5:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mmod traits;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `AsyncCommands` and `Client`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/connection.rs","byte_start":13,"byte_end":19,"line_start":1,"line_end":1,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/connection.rs","byte_start":21,"byte_end":34,"line_start":1,"line_end":1,"column_start":22,"column_end":35,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":22,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/connection.rs","byte_start":13,"byte_end":36,"line_start":1,"line_end":1,"column_start":14,"column_end":37,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":14,"highlight_end":37}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/connection.rs","byte_start":11,"byte_end":13,"line_start":1,"line_end":1,"column_start":12,"column_end":14,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":12,"highlight_end":14}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/connection.rs","byte_start":58,"byte_end":60,"line_start":1,"line_end":1,"column_start":59,"column_end":61,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":59,"highlight_end":61}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `AsyncCommands` and `Client`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/connection.rs:1:14\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse redis::{ Client, AsyncCommands, aio::ConnectionManager };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `aio::ConnectionManager`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/transaction.rs","byte_start":28,"byte_end":50,"line_start":1,"line_end":1,"column_start":29,"column_end":51,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":29,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/transaction.rs","byte_start":26,"byte_end":50,"line_start":1,"line_end":1,"column_start":27,"column_end":51,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":27,"highlight_end":51}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/transaction.rs","byte_start":11,"byte_end":13,"line_start":1,"line_end":1,"column_start":12,"column_end":14,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":12,"highlight_end":14}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/transaction.rs","byte_start":50,"byte_end":52,"line_start":1,"line_end":1,"column_start":51,"column_end":53,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":51,"highlight_end":53}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `aio::ConnectionManager`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/transaction.rs:1:29\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse redis::{ AsyncCommands, aio::ConnectionManager };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `aio::ConnectionManager`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":28,"byte_end":50,"line_start":1,"line_end":1,"column_start":29,"column_end":51,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":29,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":26,"byte_end":50,"line_start":1,"line_end":1,"column_start":27,"column_end":51,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":27,"highlight_end":51}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/pubsub.rs","byte_start":11,"byte_end":13,"line_start":1,"line_end":1,"column_start":12,"column_end":14,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":12,"highlight_end":14}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/pubsub.rs","byte_start":50,"byte_end":52,"line_start":1,"line_end":1,"column_start":51,"column_end":53,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":51,"highlight_end":53}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `aio::ConnectionManager`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pubsub.rs:1:29\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse redis::{ AsyncCommands, aio::ConnectionManager };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `aio::ConnectionManager`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/script.rs","byte_start":28,"byte_end":50,"line_start":1,"line_end":1,"column_start":29,"column_end":51,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":29,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/script.rs","byte_start":26,"byte_end":50,"line_start":1,"line_end":1,"column_start":27,"column_end":51,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":27,"highlight_end":51}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/script.rs","byte_start":11,"byte_end":13,"line_start":1,"line_end":1,"column_start":12,"column_end":14,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":12,"highlight_end":14}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/script.rs","byte_start":50,"byte_end":52,"line_start":1,"line_end":1,"column_start":51,"column_end":53,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":51,"highlight_end":53}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `aio::ConnectionManager`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/script.rs:1:29\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse redis::{ AsyncCommands, aio::ConnectionManager };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `AsyncCommands` and `aio::ConnectionManager`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/pipeline.rs","byte_start":13,"byte_end":26,"line_start":1,"line_end":1,"column_start":14,"column_end":27,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager, Pipeline };","highlight_start":14,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/pipeline.rs","byte_start":28,"byte_end":50,"line_start":1,"line_end":1,"column_start":29,"column_end":51,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager, Pipeline };","highlight_start":29,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/pipeline.rs","byte_start":13,"byte_end":52,"line_start":1,"line_end":1,"column_start":14,"column_end":53,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager, Pipeline };","highlight_start":14,"highlight_end":53}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/pipeline.rs","byte_start":11,"byte_end":13,"line_start":1,"line_end":1,"column_start":12,"column_end":14,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager, Pipeline };","highlight_start":12,"highlight_end":14}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/pipeline.rs","byte_start":60,"byte_end":62,"line_start":1,"line_end":1,"column_start":61,"column_end":63,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager, Pipeline };","highlight_start":61,"highlight_end":63}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `AsyncCommands` and `aio::ConnectionManager`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pipeline.rs:1:14\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse redis::{ AsyncCommands, aio::ConnectionManager, Pipeline };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `AsyncCommands` and `aio::ConnectionManager`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":13,"byte_end":26,"line_start":1,"line_end":1,"column_start":14,"column_end":27,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":14,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":28,"byte_end":50,"line_start":1,"line_end":1,"column_start":29,"column_end":51,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":29,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":0,"byte_end":54,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":1,"highlight_end":54},{"text":"use crate::error::{ RedisError, RedisResult };","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `AsyncCommands` and `aio::ConnectionManager`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:1:14\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse redis::{ AsyncCommands, aio::ConnectionManager };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `AsyncCommands` and `aio::ConnectionManager`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":13,"byte_end":26,"line_start":1,"line_end":1,"column_start":14,"column_end":27,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":14,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/hll.rs","byte_start":28,"byte_end":50,"line_start":1,"line_end":1,"column_start":29,"column_end":51,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":29,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":0,"byte_end":54,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":1,"highlight_end":54},{"text":"use crate::error::{ RedisError, RedisResult };","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `AsyncCommands` and `aio::ConnectionManager`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/hll.rs:1:14\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse redis::{ AsyncCommands, aio::ConnectionManager };\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `RedisError`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":163,"byte_end":173,"line_start":13,"line_end":13,"column_start":18,"column_end":28,"is_primary":true,"text":[{"text":"pub use error::{ RedisError, RedisResult };","highlight_start":18,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":163,"byte_end":175,"line_start":13,"line_end":13,"column_start":18,"column_end":30,"is_primary":true,"text":[{"text":"pub use error::{ RedisError, RedisResult };","highlight_start":18,"highlight_end":30}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/lib.rs","byte_start":161,"byte_end":163,"line_start":13,"line_end":13,"column_start":16,"column_end":18,"is_primary":true,"text":[{"text":"pub use error::{ RedisError, RedisResult };","highlight_start":16,"highlight_end":18}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/lib.rs","byte_start":186,"byte_end":188,"line_start":13,"line_end":13,"column_start":41,"column_end":43,"is_primary":true,"text":[{"text":"pub use error::{ RedisError, RedisResult };","highlight_start":41,"highlight_end":43}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `RedisError`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:13:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub use error::{ RedisError, RedisResult };\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `AsyncCommands` and `Client`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":900,"byte_end":906,"line_start":33,"line_end":33,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/lib.rs","byte_start":908,"byte_end":921,"line_start":33,"line_end":33,"column_start":22,"column_end":35,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":22,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":900,"byte_end":923,"line_start":33,"line_end":33,"column_start":14,"column_end":37,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":14,"highlight_end":37}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/lib.rs","byte_start":898,"byte_end":900,"line_start":33,"line_end":33,"column_start":12,"column_end":14,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":12,"highlight_end":14}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates/redis/src/lib.rs","byte_start":945,"byte_end":947,"line_start":33,"line_end":33,"column_start":59,"column_end":61,"is_primary":true,"text":[{"text":"use redis::{ Client, AsyncCommands, aio::ConnectionManager };","highlight_start":59,"highlight_end":61}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `AsyncCommands` and `Client`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:33:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse redis::{ Client, AsyncCommands, aio::ConnectionManager };\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `serde_json::Value`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":1019,"byte_end":1036,"line_start":37,"line_end":37,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"use serde_json::Value;","highlight_start":5,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":1015,"byte_end":1038,"line_start":37,"line_end":38,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use serde_json::Value;","highlight_start":1,"highlight_end":23},{"text":"use std::time::Duration;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `serde_json::Value`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:37:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse serde_json::Value;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::time::Duration`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":1042,"byte_end":1061,"line_start":38,"line_end":38,"column_start":5,"column_end":24,"is_primary":true,"text":[{"text":"use std::time::Duration;","highlight_start":5,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":1038,"byte_end":1063,"line_start":38,"line_end":39,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::time::Duration;","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::time::Duration`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:38:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::time::Duration;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `as_ref` found for struct `tokio::sync::MutexGuard<'_, RedisConnection>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":4447,"byte_end":4453,"line_start":133,"line_end":133,"column_start":23,"column_end":29,"is_primary":true,"text":[{"text":"        manager_guard.as_ref().cloned().ok_or(RedisError::NotConnected)","highlight_start":23,"highlight_end":29}],"label":"method not found in `MutexGuard<'_, RedisConnection>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `as_ref`, perhaps you need to implement it:\ncandidate #1: `AsRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_ref` found for struct `tokio::sync::MutexGuard<'_, RedisConnection>` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:133:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        manager_guard.as_ref().cloned().ok_or(RedisError::NotConnected)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `MutexGuard<'_, RedisConnection>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is implemented and in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait defines an item `as_ref`, perhaps you need to implement it:\u001b[0m\n\u001b[0m            candidate #1: `AsRef`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `multi` found for struct `ConnectionManager` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":5045,"byte_end":5050,"line_start":147,"line_end":147,"column_start":39,"column_end":44,"is_primary":true,"text":[{"text":"        let mut transaction = manager.multi();","highlight_start":39,"highlight_end":44}],"label":"method not found in `ConnectionManager`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `multi` found for struct `ConnectionManager` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:147:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m147\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut transaction = manager.multi();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `ConnectionManager`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`?` couldn't convert the error to `RedisError`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates/redis/src/lib.rs","byte_start":5100,"byte_end":5101,"line_start":148,"line_end":148,"column_start":47,"column_end":48,"is_primary":true,"text":[{"text":"        let result = f(&mut transaction).await?;","highlight_start":47,"highlight_end":48}],"label":"the trait `From<redis::RedisError>` is not implemented for `RedisError`, which is required by `Result<T, RedisError>: FromResidual<Result<Infallible, redis::RedisError>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/redis/src/lib.rs","byte_start":5100,"byte_end":5101,"line_start":148,"line_end":148,"column_start":47,"column_end":48,"is_primary":false,"text":[{"text":"        let result = f(&mut transaction).await?;","highlight_start":47,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"crates/redis/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the trait `FromResidual<Result<Infallible, E>>` is implemented for `Result<T, F>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Result<T, RedisError>` to implement `FromResidual<Result<Infallible, redis::RedisError>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: `?` couldn't convert the error to `RedisError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/lib.rs:148:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let result = f(&mut transaction).await?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<redis::RedisError>` is not implemented for `RedisError`, which is required by `Result<T, RedisError>: FromResidual<Result<Infallible, redis::RedisError>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `FromResidual<Result<Infallible, E>>` \u001b[0m\u001b[0m\u001b[1m\u001b[35mis\u001b[0m\u001b[0m implemented for `\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<T, F>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `Result<T, RedisError>` to implement `FromResidual<Result<Infallible, redis::RedisError>>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/connection.rs","byte_start":644,"byte_end":709,"line_start":23,"line_end":23,"column_start":5,"column_end":70,"is_primary":true,"text":[{"text":"    pub async fn connect(&self, config: &DbConfig) -> RedisResult<()> {","highlight_start":5,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/connection.rs","byte_start":1154,"byte_end":1165,"line_start":37,"line_end":37,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut test_conn).await","highlight_start":14,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[warn(dependency_on_unit_never_type_fallback)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/connection.rs:23:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn connect(&self, config: &DbConfig) -> RedisResult<()> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/connection.rs:37:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut test_conn).await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(dependency_on_unit_never_type_fallback)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/transaction.rs","byte_start":567,"byte_end":615,"line_start":22,"line_end":22,"column_start":5,"column_end":53,"is_primary":true,"text":[{"text":"    pub async fn begin(&mut self) -> RedisResult<()> {","highlight_start":5,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/transaction.rs","byte_start":869,"byte_end":880,"line_start":30,"line_end":30,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut conn).await","highlight_start":14,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/transaction.rs:22:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn begin(&mut self) -> RedisResult<()> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/transaction.rs:30:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut conn).await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/transaction.rs","byte_start":1067,"byte_end":1116,"line_start":38,"line_end":38,"column_start":5,"column_end":54,"is_primary":true,"text":[{"text":"    pub async fn commit(&mut self) -> RedisResult<()> {","highlight_start":5,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/transaction.rs","byte_start":1366,"byte_end":1377,"line_start":46,"line_end":46,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut conn).await","highlight_start":14,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/transaction.rs:38:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn commit(&mut self) -> RedisResult<()> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/transaction.rs:46:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut conn).await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/transaction.rs","byte_start":1567,"byte_end":1618,"line_start":54,"line_end":54,"column_start":5,"column_end":56,"is_primary":true,"text":[{"text":"    pub async fn rollback(&mut self) -> RedisResult<()> {","highlight_start":5,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/transaction.rs","byte_start":1871,"byte_end":1882,"line_start":62,"line_end":62,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut conn).await","highlight_start":14,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/transaction.rs:54:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn rollback(&mut self) -> RedisResult<()> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/transaction.rs:62:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut conn).await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":1831,"byte_end":1839,"line_start":55,"line_end":55,"column_start":40,"column_end":48,"is_primary":true,"text":[{"text":"            .ok_or_else(|| RedisError::Prepared(format!(\"Statement '{}' not found\", name)))?;","highlight_start":40,"highlight_end":48}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:55:40\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .ok_or_else(|| RedisError::Prepared(format!(\"Statement '{}' not found\", name)))?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":1989,"byte_end":1997,"line_start":59,"line_end":59,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"                RedisError::Prepared(","highlight_start":29,"highlight_end":37}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:59:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                RedisError::Prepared(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":2828,"byte_end":2836,"line_start":75,"line_end":75,"column_start":34,"column_end":42,"is_primary":true,"text":[{"text":"            _ => Err(RedisError::Prepared(format!(\"Unsupported command: {}\", parts[0]))),","highlight_start":34,"highlight_end":42}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:75:34\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            _ => Err(RedisError::Prepared(format!(\"Unsupported command: {}\", parts[0]))),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":3183,"byte_end":3191,"line_start":87,"line_end":87,"column_start":36,"column_end":44,"is_primary":true,"text":[{"text":"            return Err(RedisError::Prepared(\"Missing key for GET command\".to_string()));","highlight_start":36,"highlight_end":44}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:87:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            return Err(RedisError::Prepared(\"Missing key for GET command\".to_string()));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `get` found for mutable reference `&mut ConnectionManager` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":3340,"byte_end":3358,"line_start":91,"line_end":92,"column_start":37,"column_end":14,"is_primary":false,"text":[{"text":"        let value: Option<String> = conn","highlight_start":37,"highlight_end":41},{"text":"            .get(&key).await","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/prepared.rs","byte_start":3358,"byte_end":3361,"line_start":92,"line_end":92,"column_start":14,"column_end":17,"is_primary":true,"text":[{"text":"            .get(&key).await","highlight_start":14,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"there is a method `hget` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/commands/macros.rs","byte_start":6752,"byte_end":7021,"line_start":162,"line_end":167,"column_start":17,"column_end":40,"is_primary":true,"text":[{"text":"                fn $name<$lifetime, $($tyargs: $ty + Send + Sync + $lifetime,)* RV>(","highlight_start":17,"highlight_end":85},{"text":"                    & $lifetime mut self","highlight_start":1,"highlight_end":41},{"text":"                    $(, $argname: $argty)*","highlight_start":1,"highlight_end":43},{"text":"                ) -> crate::types::RedisFuture<'a, RV>","highlight_start":1,"highlight_end":55},{"text":"                where","highlight_start":1,"highlight_end":22},{"text":"                    RV: FromRedisValue,","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/commands/mod.rs","byte_start":2151,"byte_end":65818,"line_start":41,"line_end":1873,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"implement_commands! {","highlight_start":1,"highlight_end":1},{"text":"    'a","highlight_start":1,"highlight_end":1},{"text":"    // most common operations","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key.  If key is a vec this becomes an `MGET`.","highlight_start":1,"highlight_end":1},{"text":"    fn get<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if key.is_single_arg() { \"GET\" } else { \"MGET\" }).arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get values of keys","highlight_start":1,"highlight_end":1},{"text":"    fn mget<K: ToRedisArgs>(key: K){","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"MGET\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all keys matching pattern","highlight_start":1,"highlight_end":1},{"text":"    fn keys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"KEYS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn set<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SET\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key with options.","highlight_start":1,"highlight_end":1},{"text":"    fn set_options<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: SetOptions) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SET\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":1},{"text":"    #[allow(deprecated)]","highlight_start":1,"highlight_end":1},{"text":"    #[deprecated(since = \"0.22.4\", note = \"Renamed to mset() to reflect Redis name\")]","highlight_start":1,"highlight_end":1},{"text":"    fn set_multiple<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":1},{"text":"    fn mset<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, seconds: u64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SETEX\").arg(key).arg(seconds).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration in milliseconds of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn pset_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, milliseconds: u64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PSETEX\").arg(key).arg(milliseconds).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value of a key, only if the key does not exist","highlight_start":1,"highlight_end":1},{"text":"    fn set_nx<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SETNX\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values failing if at least one already exists.","highlight_start":1,"highlight_end":1},{"text":"    fn mset_nx<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"MSETNX\").arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key and return its old value.","highlight_start":1,"highlight_end":1},{"text":"    fn getset<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETSET\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get a range of bytes/substring from the value of a key. Negative values provide an offset from the end of the value.","highlight_start":1,"highlight_end":1},{"text":"    fn getrange<K: ToRedisArgs>(key: K, from: isize, to: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETRANGE\").arg(key).arg(from).arg(to)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Overwrite the part of the value stored in key at the specified offset.","highlight_start":1,"highlight_end":1},{"text":"    fn setrange<K: ToRedisArgs, V: ToRedisArgs>(key: K, offset: isize, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SETRANGE\").arg(key).arg(offset).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete one or more keys.","highlight_start":1,"highlight_end":1},{"text":"    fn del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"DEL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a key exists.","highlight_start":1,"highlight_end":1},{"text":"    fn exists<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"EXISTS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the type of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn key_type<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"TYPE\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in seconds.","highlight_start":1,"highlight_end":1},{"text":"    fn expire<K: ToRedisArgs>(key: K, seconds: i64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"EXPIRE\").arg(key).arg(seconds)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp.","highlight_start":1,"highlight_end":1},{"text":"    fn expire_at<K: ToRedisArgs>(key: K, ts: i64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"EXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in milliseconds.","highlight_start":1,"highlight_end":1},{"text":"    fn pexpire<K: ToRedisArgs>(key: K, ms: i64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PEXPIRE\").arg(key).arg(ms)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp in milliseconds.","highlight_start":1,"highlight_end":1},{"text":"    fn pexpire_at<K: ToRedisArgs>(key: K, ts: i64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PEXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove the expiration from a key.","highlight_start":1,"highlight_end":1},{"text":"    fn persist<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PERSIST\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn ttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"TTL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key in milliseconds.","highlight_start":1,"highlight_end":1},{"text":"    fn pttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PTTL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and set expiration","highlight_start":1,"highlight_end":1},{"text":"    fn get_ex<K: ToRedisArgs>(key: K, expire_at: Expiry) {","highlight_start":1,"highlight_end":1},{"text":"        let (option, time_arg) = match expire_at {","highlight_start":1,"highlight_end":1},{"text":"            Expiry::EX(sec) => (\"EX\", Some(sec)),","highlight_start":1,"highlight_end":1},{"text":"            Expiry::PX(ms) => (\"PX\", Some(ms)),","highlight_start":1,"highlight_end":1},{"text":"            Expiry::EXAT(timestamp_sec) => (\"EXAT\", Some(timestamp_sec)),","highlight_start":1,"highlight_end":1},{"text":"            Expiry::PXAT(timestamp_ms) => (\"PXAT\", Some(timestamp_ms)),","highlight_start":1,"highlight_end":1},{"text":"            Expiry::PERSIST => (\"PERSIST\", None),","highlight_start":1,"highlight_end":1},{"text":"        };","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETEX\").arg(key).arg(option).arg(time_arg)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and delete it","highlight_start":1,"highlight_end":1},{"text":"    fn get_del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETDEL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key.","highlight_start":1,"highlight_end":1},{"text":"    fn rename<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RENAME\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key, only if the new key does not exist.","highlight_start":1,"highlight_end":1},{"text":"    fn rename_nx<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RENAMENX\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unlink one or more keys.","highlight_start":1,"highlight_end":1},{"text":"    fn unlink<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"UNLINK\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // common string operations","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Append a value to a key.","highlight_start":1,"highlight_end":1},{"text":"    fn append<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"APPEND\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increment the numeric value of a key by the given amount.  This","highlight_start":1,"highlight_end":1},{"text":"    /// issues a `INCRBY` or `INCRBYFLOAT` depending on the type.","highlight_start":1,"highlight_end":1},{"text":"    fn incr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":1},{"text":"            \"INCRBYFLOAT\"","highlight_start":1,"highlight_end":1},{"text":"        } else {","highlight_start":1,"highlight_end":1},{"text":"            \"INCRBY\"","highlight_start":1,"highlight_end":1},{"text":"        }).arg(key).arg(delta)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Decrement the numeric value of a key by the given amount.","highlight_start":1,"highlight_end":1},{"text":"    fn decr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"DECRBY\").arg(key).arg(delta)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets or clears the bit at offset in the string value stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn setbit<K: ToRedisArgs>(key: K, offset: usize, value: bool) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SETBIT\").arg(key).arg(offset).arg(i32::from(value))","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the bit value at offset in the string value stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn getbit<K: ToRedisArgs>(key: K, offset: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETBIT\").arg(key).arg(offset)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string.","highlight_start":1,"highlight_end":1},{"text":"    fn bitcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITCOUNT\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string in a range.","highlight_start":1,"highlight_end":1},{"text":"    fn bitcount_range<K: ToRedisArgs>(key: K, start: usize, end: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITCOUNT\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise AND between multiple keys (containing string values)","highlight_start":1,"highlight_end":1},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":1},{"text":"    fn bit_and<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITOP\").arg(\"AND\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise OR between multiple keys (containing string values)","highlight_start":1,"highlight_end":1},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":1},{"text":"    fn bit_or<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITOP\").arg(\"OR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise XOR between multiple keys (containing string values)","highlight_start":1,"highlight_end":1},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":1},{"text":"    fn bit_xor<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITOP\").arg(\"XOR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise NOT of the key (containing string values)","highlight_start":1,"highlight_end":1},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":1},{"text":"    fn bit_not<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckey: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITOP\").arg(\"NOT\").arg(dstkey).arg(srckey)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the length of the value stored in a key.","highlight_start":1,"highlight_end":1},{"text":"    fn strlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"STRLEN\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hash operations","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hget<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if field.is_single_arg() { \"HGET\" } else { \"HMGET\" }).arg(key).arg(field)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hdel<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HDEL\").arg(key).arg(field)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hset<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HSET\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash if it does not exist.","highlight_start":1,"highlight_end":1},{"text":"    fn hset_nx<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HSETNX\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a multiple fields in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hset_multiple<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, items: &'a [(F, V)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HMSET\").arg(key).arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments a value.","highlight_start":1,"highlight_end":1},{"text":"    fn hincr<K: ToRedisArgs, F: ToRedisArgs, D: ToRedisArgs>(key: K, field: F, delta: D) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":1},{"text":"            \"HINCRBYFLOAT\"","highlight_start":1,"highlight_end":1},{"text":"        } else {","highlight_start":1,"highlight_end":1},{"text":"            \"HINCRBY\"","highlight_start":1,"highlight_end":1},{"text":"        }).arg(key).arg(field).arg(delta)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Checks if a field in a hash exists.","highlight_start":1,"highlight_end":1},{"text":"    fn hexists<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HEXISTS\").arg(key).arg(field)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the keys in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hkeys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HKEYS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the values in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hvals<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HVALS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the fields and values in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hgetall<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HGETALL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets the length of a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HLEN\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // list operations","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element from a list, push it to another list","highlight_start":1,"highlight_end":1},{"text":"    /// and return it; or block until one is available","highlight_start":1,"highlight_end":1},{"text":"    fn blmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction, timeout: f64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BLMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":1},{"text":"    /// provided key names; or blocks until one is available.","highlight_start":1,"highlight_end":1},{"text":"    fn blmpop<K: ToRedisArgs>(timeout: f64, numkeys: usize, key: K, dir: Direction, count: usize){","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BLMPOP\").arg(timeout).arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the first element in a list, or block until one is available.","highlight_start":1,"highlight_end":1},{"text":"    fn blpop<K: ToRedisArgs>(key: K, timeout: f64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BLPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the last element in a list, or block until one is available.","highlight_start":1,"highlight_end":1},{"text":"    fn brpop<K: ToRedisArgs>(key: K, timeout: f64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BRPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it;","highlight_start":1,"highlight_end":1},{"text":"    /// or block until one is available.","highlight_start":1,"highlight_end":1},{"text":"    fn brpoplpush<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, timeout: f64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BRPOPLPUSH\").arg(srckey).arg(dstkey).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get an element from a list by its index.","highlight_start":1,"highlight_end":1},{"text":"    fn lindex<K: ToRedisArgs>(key: K, index: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LINDEX\").arg(key).arg(index)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element before another element in a list.","highlight_start":1,"highlight_end":1},{"text":"    fn linsert_before<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"BEFORE\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element after another element in a list.","highlight_start":1,"highlight_end":1},{"text":"    fn linsert_after<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"AFTER\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the length of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn llen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LLEN\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element a list, push it to another list and return it","highlight_start":1,"highlight_end":1},{"text":"    fn lmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":1},{"text":"    /// provided key names.","highlight_start":1,"highlight_end":1},{"text":"    fn lmpop<K: ToRedisArgs>( numkeys: usize, key: K, dir: Direction, count: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LMPOP\").arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` first elements of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// If `count` is not specified, then defaults to first element.","highlight_start":1,"highlight_end":1},{"text":"    fn lpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the index of the first matching value of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn lpos<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: LposOptions) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LPOS\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the head of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn lpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts a value at the head of the list stored at key, only if key","highlight_start":1,"highlight_end":1},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":1},{"text":"    fn lpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the specified elements of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn lrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes the first count occurrences of elements equal to value","highlight_start":1,"highlight_end":1},{"text":"    /// from the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn lrem<K: ToRedisArgs, V: ToRedisArgs>(key: K, count: isize, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LREM\").arg(key).arg(count).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim an existing list so that it will contain only the specified","highlight_start":1,"highlight_end":1},{"text":"    /// range of elements specified.","highlight_start":1,"highlight_end":1},{"text":"    fn ltrim<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LTRIM\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets the list element at index to value","highlight_start":1,"highlight_end":1},{"text":"    fn lset<K: ToRedisArgs, V: ToRedisArgs>(key: K, index: isize, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LSET\").arg(key).arg(index).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` last elements of the list stored at key","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// If `count` is not specified, then defaults to last element.","highlight_start":1,"highlight_end":1},{"text":"    fn rpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it.","highlight_start":1,"highlight_end":1},{"text":"    fn rpoplpush<K: ToRedisArgs, D: ToRedisArgs>(key: K, dstkey: D) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RPOPLPUSH\").arg(key).arg(dstkey)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the tail of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn rpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts value at the tail of the list stored at key, only if key","highlight_start":1,"highlight_end":1},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":1},{"text":"    fn rpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // set commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one or more members to a set.","highlight_start":1,"highlight_end":1},{"text":"    fn sadd<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SADD\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a set.","highlight_start":1,"highlight_end":1},{"text":"    fn scard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SCARD\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets.","highlight_start":1,"highlight_end":1},{"text":"    fn sdiff<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SDIFF\").arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":1},{"text":"    fn sdiffstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SDIFFSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets.","highlight_start":1,"highlight_end":1},{"text":"    fn sinter<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SINTER\").arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":1},{"text":"    fn sinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SINTERSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a given value is a member of a set.","highlight_start":1,"highlight_end":1},{"text":"    fn sismember<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SISMEMBER\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get all the members in a set.","highlight_start":1,"highlight_end":1},{"text":"    fn smembers<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SMEMBERS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Move a member from one set to another.","highlight_start":1,"highlight_end":1},{"text":"    fn smove<S: ToRedisArgs, D: ToRedisArgs, M: ToRedisArgs>(srckey: S, dstkey: D, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SMOVE\").arg(srckey).arg(dstkey).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and return a random member from a set.","highlight_start":1,"highlight_end":1},{"text":"    fn spop<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SPOP\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get one random member from a set.","highlight_start":1,"highlight_end":1},{"text":"    fn srandmember<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SRANDMEMBER\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get multiple random members from a set.","highlight_start":1,"highlight_end":1},{"text":"    fn srandmember_multiple<K: ToRedisArgs>(key: K, count: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a set.","highlight_start":1,"highlight_end":1},{"text":"    fn srem<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SREM\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets.","highlight_start":1,"highlight_end":1},{"text":"    fn sunion<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SUNION\").arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":1},{"text":"    fn sunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SUNIONSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // sorted set commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one member to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":1},{"text":"    fn zadd<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, member: M, score: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZADD\").arg(key).arg(score).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple members to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":1},{"text":"    fn zadd_multiple<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, items: &'a [(S, M)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZADD\").arg(key).arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zcard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZCARD\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the members in a sorted set with scores within the given values.","highlight_start":1,"highlight_end":1},{"text":"    fn zcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments the member in a sorted set at key by delta.","highlight_start":1,"highlight_end":1},{"text":"    /// If the member does not exist, it is added with delta as its score.","highlight_start":1,"highlight_end":1},{"text":"    fn zincr<K: ToRedisArgs, M: ToRedisArgs, D: ToRedisArgs>(key: K, member: M, delta: D) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINCRBY\").arg(key).arg(delta).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the number of members in a sorted set between a given lexicographical range.","highlight_start":1,"highlight_end":1},{"text":"    fn zlexcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZLEXCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the member with the highest score in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    /// Blocks until a member is available otherwise.","highlight_start":1,"highlight_end":1},{"text":"    fn bzpopmax<K: ToRedisArgs>(key: K, timeout: f64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BZPOPMAX\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores in a sorted set","highlight_start":1,"highlight_end":1},{"text":"    fn zpopmax<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZPOPMAX\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the member with the lowest score in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    /// Blocks until a member is available otherwise.","highlight_start":1,"highlight_end":1},{"text":"    fn bzpopmin<K: ToRedisArgs>(key: K, timeout: f64) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BZPOPMIN\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores in a sorted set","highlight_start":1,"highlight_end":1},{"text":"    fn zpopmin<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZPOPMIN\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores,","highlight_start":1,"highlight_end":1},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":1},{"text":"    /// Blocks until a member is available otherwise.","highlight_start":1,"highlight_end":1},{"text":"    fn bzmpop_max<K: ToRedisArgs>(timeout: f64, keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BZMPOP\").arg(timeout).arg(keys.len()).arg(keys).arg(\"MAX\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores,","highlight_start":1,"highlight_end":1},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":1},{"text":"    fn zmpop_max<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MAX\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores,","highlight_start":1,"highlight_end":1},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":1},{"text":"    /// Blocks until a member is available otherwise.","highlight_start":1,"highlight_end":1},{"text":"    fn bzmpop_min<K: ToRedisArgs>(timeout: f64, keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BZMPOP\").arg(timeout).arg(keys.len()).arg(keys).arg(\"MIN\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores,","highlight_start":1,"highlight_end":1},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":1},{"text":"    fn zmpop_min<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MIN\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set (or 1 if `count == None`)","highlight_start":1,"highlight_end":1},{"text":"    fn zrandmember<K: ToRedisArgs>(key: K, count: Option<isize>) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set with scores","highlight_start":1,"highlight_end":1},{"text":"    fn zrandmember_withscores<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index","highlight_start":1,"highlight_end":1},{"text":"    fn zrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":1},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebylex_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"            key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebylex<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":1},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebylex_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"            key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebyscore_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebyscore_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":1},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebyscore_limit_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":1},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zrem<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREM\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set between the given lexicographical range.","highlight_start":1,"highlight_end":1},{"text":"    fn zrembylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREMRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given indexes.","highlight_start":1,"highlight_end":1},{"text":"    fn zremrangebyrank<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREMRANGEBYRANK\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrembyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREMRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":1},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":1},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebyscore<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebyscore_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebyscore_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":1},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebyscore_limit_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":1},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set, with scores ordered from high to low.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the score associated with the given member in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zscore<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZSCORE\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the scores associated with multiple members in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zscore_multiple<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: &'a [M]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZMSCORE\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hyperloglog commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified elements to the specified HyperLogLog.","highlight_start":1,"highlight_end":1},{"text":"    fn pfadd<K: ToRedisArgs, E: ToRedisArgs>(key: K, element: E) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PFADD\").arg(key).arg(element)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the approximated cardinality of the set(s) observed by the","highlight_start":1,"highlight_end":1},{"text":"    /// HyperLogLog at key(s).","highlight_start":1,"highlight_end":1},{"text":"    fn pfcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PFCOUNT\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Merge N different HyperLogLogs into a single one.","highlight_start":1,"highlight_end":1},{"text":"    fn pfmerge<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PFMERGE\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Posts a message to the given channel.","highlight_start":1,"highlight_end":1},{"text":"    fn publish<K: ToRedisArgs, E: ToRedisArgs>(channel: K, message: E) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PUBLISH\").arg(channel).arg(message)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Object commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the encoding of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn object_encoding<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"OBJECT\").arg(\"ENCODING\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the time in seconds since the last access of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn object_idletime<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"OBJECT\").arg(\"IDLETIME\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the logarithmic access frequency counter of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn object_freq<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"OBJECT\").arg(\"FREQ\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the reference count of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn object_refcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"OBJECT\").arg(\"REFCOUNT\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // ACL commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":1},{"text":"    /// configuration option), this command will reload the ACLs from the file,","highlight_start":1,"highlight_end":1},{"text":"    /// replacing all the current ACL rules with the ones defined in the file.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_load<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"LOAD\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":1},{"text":"    /// configuration option), this command will save the currently defined","highlight_start":1,"highlight_end":1},{"text":"    /// ACLs from the server memory to the ACL file.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_save<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"SAVE\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the currently active ACL rules in the Redis server.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_list<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"LIST\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of all the usernames of the currently configured users in","highlight_start":1,"highlight_end":1},{"text":"    /// the Redis ACL system.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_users<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"USERS\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all the rules defined for an existing ACL user.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_getuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"GETUSER\").arg(username)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user without any privilege.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_setuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user with the specified rules or modify the rules of","highlight_start":1,"highlight_end":1},{"text":"    /// an existing user.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_setuser_rules<K: ToRedisArgs>(username: K, rules: &'a [acl::Rule]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username).arg(rules)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete all the specified ACL users and terminate all the connections","highlight_start":1,"highlight_end":1},{"text":"    /// that are authenticated with such users.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_deluser<K: ToRedisArgs>(usernames: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"DELUSER\").arg(usernames)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the available ACL categories.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_cat<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"CAT\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows all the Redis commands in the specified category.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_cat_categoryname<K: ToRedisArgs>(categoryname: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"CAT\").arg(categoryname)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 256-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_genpass<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"GENPASS\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 1-to-1024-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_genpass_bits<>(bits: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"GENPASS\").arg(bits)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the username the current connection is authenticated with.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_whoami<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"WHOAMI\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of recent ACL security events","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_log<>(count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Clears the ACL log.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_log_reset<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(\"RESET\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a helpful text describing the different subcommands.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_help<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"HELP\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":1},{"text":"    // geospatial commands","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified geospatial items to the specified key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Every member has to be written as a tuple of `(longitude, latitude,","highlight_start":1,"highlight_end":1},{"text":"    /// member_name)`. It can be a single tuple, or a vector of tuples.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// `longitude, latitude` can be set using [`redis::geo::Coord`][1].","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the number of elements added to the sorted set, not including","highlight_start":1,"highlight_end":1},{"text":"    /// elements already existing for which the score was updated.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Example","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, Connection, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn add_point(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":1},{"text":"    ///     con.geo_add(\"my_gis\", (Coord::lon_lat(13.361389, 38.115556), \"Palermo\"))","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn add_point_with_tuples(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":1},{"text":"    ///     con.geo_add(\"my_gis\", (\"13.361389\", \"38.115556\", \"Palermo\"))","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn add_many_points(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":1},{"text":"    ///     con.geo_add(\"my_gis\", &[","highlight_start":1,"highlight_end":1},{"text":"    ///         (\"13.361389\", \"38.115556\", \"Palermo\"),","highlight_start":1,"highlight_end":1},{"text":"    ///         (\"15.087269\", \"37.502669\", \"Catania\")","highlight_start":1,"highlight_end":1},{"text":"    ///     ])","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_add<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEOADD\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the distance between two members in the geospatial index","highlight_start":1,"highlight_end":1},{"text":"    /// represented by the sorted set.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// If one or both the members are missing, the command returns NULL, so","highlight_start":1,"highlight_end":1},{"text":"    /// it may be convenient to parse its response as either `Option<f64>` or","highlight_start":1,"highlight_end":1},{"text":"    /// `Option<String>`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Example","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::geo::Unit;","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn get_dists(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<f64> = con.geo_dist(","highlight_start":1,"highlight_end":1},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":1},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":1},{"text":"    ///         \"Catania\",","highlight_start":1,"highlight_end":1},{"text":"    ///         Unit::Kilometers","highlight_start":1,"highlight_end":1},{"text":"    ///     );","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is Ok(166.2742)","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<Option<f64>> = con.geo_dist(","highlight_start":1,"highlight_end":1},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":1},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":1},{"text":"    ///         \"Atlantis\",","highlight_start":1,"highlight_end":1},{"text":"    ///         Unit::Meters","highlight_start":1,"highlight_end":1},{"text":"    ///     );","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is Ok(None)","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_dist<K: ToRedisArgs, M1: ToRedisArgs, M2: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        member1: M1,","highlight_start":1,"highlight_end":1},{"text":"        member2: M2,","highlight_start":1,"highlight_end":1},{"text":"        unit: geo::Unit","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEODIST\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(member1)","highlight_start":1,"highlight_end":1},{"text":"            .arg(member2)","highlight_start":1,"highlight_end":1},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return valid [Geohash][1] strings representing the position of one or","highlight_start":1,"highlight_end":1},{"text":"    /// more members of the geospatial index represented by the sorted set at","highlight_start":1,"highlight_end":1},{"text":"    /// key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [1]: https://en.wikipedia.org/wiki/Geohash","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Example","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn get_hash(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", \"Palermo\");","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is vec![\"sqc8b49rny0\"]","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is vec![\"sqc8b49rny0\", \"sqdtr74hyu0\"]","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_hash<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEOHASH\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the positions of all the specified members of the geospatial","highlight_start":1,"highlight_end":1},{"text":"    /// index represented by the sorted set at key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Every position is a pair of `(longitude, latitude)`. [`redis::geo::Coord`][1]","highlight_start":1,"highlight_end":1},{"text":"    /// can be used to convert these value in a struct.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Example","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn get_position(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<Vec<Vec<f64>>> = con.geo_pos(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is [ [ 13.361389, 38.115556 ], [ 15.087269, 37.502669 ] ];","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: Vec<Coord<f64>> = con.geo_pos(\"my_gis\", \"Palermo\").unwrap();","highlight_start":1,"highlight_end":1},{"text":"    ///     // x[0].longitude is 13.361389","highlight_start":1,"highlight_end":1},{"text":"    ///     // x[0].latitude is 38.115556","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_pos<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEOPOS\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the members of a sorted set populated with geospatial information","highlight_start":1,"highlight_end":1},{"text":"    /// using [`geo_add`](#method.geo_add), which are within the borders of the area","highlight_start":1,"highlight_end":1},{"text":"    /// specified with the center location and the maximum distance from the center","highlight_start":1,"highlight_end":1},{"text":"    /// (the radius).","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Every item in the result can be read with [`redis::geo::RadiusSearchResult`][1],","highlight_start":1,"highlight_end":1},{"text":"    /// which support the multiple formats returned by `GEORADIUS`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [1]: ./geo/struct.RadiusSearchResult.html","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::geo::{RadiusOptions, RadiusSearchResult, RadiusOrder, Unit};","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn radius(con: &mut redis::Connection) -> Vec<RadiusSearchResult> {","highlight_start":1,"highlight_end":1},{"text":"    ///     let opts = RadiusOptions::default().with_dist().order(RadiusOrder::Asc);","highlight_start":1,"highlight_end":1},{"text":"    ///     con.geo_radius(\"my_gis\", 15.90, 37.21, 51.39, Unit::Kilometers, opts).unwrap()","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_radius<K: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        longitude: f64,","highlight_start":1,"highlight_end":1},{"text":"        latitude: f64,","highlight_start":1,"highlight_end":1},{"text":"        radius: f64,","highlight_start":1,"highlight_end":1},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":1},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEORADIUS\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(longitude)","highlight_start":1,"highlight_end":1},{"text":"            .arg(latitude)","highlight_start":1,"highlight_end":1},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":1},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":1},{"text":"            .arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Retrieve members selected by distance with the center of `member`. The","highlight_start":1,"highlight_end":1},{"text":"    /// member itself is always contained in the results.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_radius_by_member<K: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        member: M,","highlight_start":1,"highlight_end":1},{"text":"        radius: f64,","highlight_start":1,"highlight_end":1},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":1},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEORADIUSBYMEMBER\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(member)","highlight_start":1,"highlight_end":1},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":1},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":1},{"text":"            .arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":1},{"text":"    // streams commands","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Ack pending stream messages checked out by a consumer.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XACK <key> <group> <id> <id> ... <id>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xack<K: ToRedisArgs, G: ToRedisArgs, I: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [I]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XACK\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message by `key`. Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XADD key <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xadd<K: ToRedisArgs, ID: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        id: ID,","highlight_start":1,"highlight_end":1},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message by `key`.","highlight_start":1,"highlight_end":1},{"text":"    /// Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XADD key <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xadd_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        id: ID,","highlight_start":1,"highlight_end":1},{"text":"        map: BTM","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(map)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xadd_maxlen<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        ID: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        F: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        V: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":1},{"text":"        id: ID,","highlight_start":1,"highlight_end":1},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"            .arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xadd_maxlen_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":1},{"text":"        id: ID,","highlight_start":1,"highlight_end":1},{"text":"        map: BTM","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"            .arg(map)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Claim pending, unacked messages, after some period of time,","highlight_start":1,"highlight_end":1},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This method only accepts the must-have arguments for claiming messages.","highlight_start":1,"highlight_end":1},{"text":"    /// If optional arguments are required, see `xclaim_options` below.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> [<ID-1> <ID-2>]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xclaim<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs, MIT: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        consumer: C,","highlight_start":1,"highlight_end":1},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":1},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":1},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the optional arguments version for claiming unacked, pending messages","highlight_start":1,"highlight_end":1},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Connection,Commands,RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::streams::{StreamClaimOptions,StreamClaimReply};","highlight_start":1,"highlight_end":1},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":1},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Claim all pending messages for key \"k1\",","highlight_start":1,"highlight_end":1},{"text":"    /// // from group \"g1\", checked out by consumer \"c1\"","highlight_start":1,"highlight_end":1},{"text":"    /// // for 10ms with RETRYCOUNT 2 and FORCE","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":1},{"text":"    ///     .with_force()","highlight_start":1,"highlight_end":1},{"text":"    ///     .retry(2);","highlight_start":1,"highlight_end":1},{"text":"    /// let results: RedisResult<StreamClaimReply> =","highlight_start":1,"highlight_end":1},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // All optional arguments return a `Result<StreamClaimReply>` with one exception:","highlight_start":1,"highlight_end":1},{"text":"    /// // Passing JUSTID returns only the message `id` and omits the HashMap for each message.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":1},{"text":"    ///     .with_justid();","highlight_start":1,"highlight_end":1},{"text":"    /// let results: RedisResult<Vec<String>> =","highlight_start":1,"highlight_end":1},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>","highlight_start":1,"highlight_end":1},{"text":"    ///     [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]","highlight_start":1,"highlight_end":1},{"text":"    ///     [FORCE] [JUSTID]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xclaim_options<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        MIT: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        consumer: C,","highlight_start":1,"highlight_end":1},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":1},{"text":"        options: streams::StreamClaimOptions","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":1},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":1},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":1},{"text":"            .arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a list of `id`s for a given stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XDEL <key> [<ID1> <ID2> ... <IDN>]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xdel<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XDEL\").arg(key).arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This command is used for creating a consumer `group`. It expects the stream key","highlight_start":1,"highlight_end":1},{"text":"    /// to already exist. Otherwise, use `xgroup_create_mkstream` if it doesn't.","highlight_start":1,"highlight_end":1},{"text":"    /// The `id` is the starting message id all consumers should read from. Use `$` If you want","highlight_start":1,"highlight_end":1},{"text":"    /// all consumers to read from the last message added to stream.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_create<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        id: ID","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the alternate version for creating a consumer `group`","highlight_start":1,"highlight_end":1},{"text":"    /// which makes the stream if it doesn't exist.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $> [MKSTREAM]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_create_mkstream<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        id: ID","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"MKSTREAM\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Alter which `id` you want consumers to begin reading from an existing","highlight_start":1,"highlight_end":1},{"text":"    /// consumer `group`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_setid<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        id: ID","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"SETID\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Destroy an existing consumer `group` for a given stream `key`","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_destroy<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\").arg(\"DESTROY\").arg(key).arg(group)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This deletes a `consumer` from an existing consumer `group`","highlight_start":1,"highlight_end":1},{"text":"    /// for given stream `key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP DELCONSUMER <key> <groupname> <consumername>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_delconsumer<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        consumer: C","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"DELCONSUMER\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This returns all info details about","highlight_start":1,"highlight_end":1},{"text":"    /// which consumers have read messages for given consumer `group`.","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamInfoConsumersReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":1},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XINFO CONSUMERS <key> <group>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xinfo_consumers<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XINFO\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"CONSUMERS\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all consumer `group`s created for a given stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamInfoGroupsReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":1},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XINFO GROUPS <key>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xinfo_groups<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XINFO\").arg(\"GROUPS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns info about high-level stream details","highlight_start":1,"highlight_end":1},{"text":"    /// (first & last message `id`, length, number of groups, etc.)","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamInfoStreamReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":1},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XINFO STREAM <key>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xinfo_stream<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XINFO\").arg(\"STREAM\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the number of messages for a given stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XLEN <key>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XLEN\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is a basic version of making XPENDING command calls which only","highlight_start":1,"highlight_end":1},{"text":"    /// passes a stream `key` and consumer `group` and it","highlight_start":1,"highlight_end":1},{"text":"    /// returns details about which consumers have pending messages","highlight_start":1,"highlight_end":1},{"text":"    /// that haven't been acked.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// You can use this method along with","highlight_start":1,"highlight_end":1},{"text":"    /// `xclaim` or `xclaim_options` for determining which messages","highlight_start":1,"highlight_end":1},{"text":"    /// need to be retried.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamPendingReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XPENDING <key> <group> [<start> <stop> <count> [<consumer>]]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xpending<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G","highlight_start":1,"highlight_end":1},{"text":"    )  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XPENDING\").arg(key).arg(group)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This XPENDING version returns a list of all messages over the range.","highlight_start":1,"highlight_end":1},{"text":"    /// You can use this for paginating pending messages (but without the message HashMap).","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":1},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XPENDING <key> <group> <start> <stop> <count>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xpending_count<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        C: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        count: C","highlight_start":1,"highlight_end":1},{"text":"    )  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(start)","highlight_start":1,"highlight_end":1},{"text":"            .arg(end)","highlight_start":1,"highlight_end":1},{"text":"            .arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// An alternate version of `xpending_count` which filters by `consumer` name.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":1},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XPENDING <key> <group> <start> <stop> <count> <consumer>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xpending_consumer_count<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        CN: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        count: C,","highlight_start":1,"highlight_end":1},{"text":"        consumer: CN","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(start)","highlight_start":1,"highlight_end":1},{"text":"            .arg(end)","highlight_start":1,"highlight_end":1},{"text":"            .arg(count)","highlight_start":1,"highlight_end":1},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a range of messages in a given stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Set `start` to `-` to begin at the first message.","highlight_start":1,"highlight_end":1},{"text":"    /// Set `end` to `+` to end the most recent message.","highlight_start":1,"highlight_end":1},{"text":"    /// You can pass message `id` to both `start` and `end`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamRangeReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XRANGE key start end","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrange<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        end: E","highlight_start":1,"highlight_end":1},{"text":"    )  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XRANGE\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A helper method for automatically returning all messages in a stream by `key`.","highlight_start":1,"highlight_end":1},{"text":"    /// **Use with caution!**","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XRANGE key - +","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrange_all<K: ToRedisArgs>(key: K)  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XRANGE\").arg(key).arg(\"-\").arg(\"+\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A method for paginating a stream by `key`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XRANGE key start end [COUNT <n>]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrange_count<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        count: C","highlight_start":1,"highlight_end":1},{"text":"    )  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XRANGE\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(start)","highlight_start":1,"highlight_end":1},{"text":"            .arg(end)","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Read a list of `id`s for each stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    /// This is the basic form of reading streams.","highlight_start":1,"highlight_end":1},{"text":"    /// For more advanced control, like blocking, limiting, or reading by consumer `group`,","highlight_start":1,"highlight_end":1},{"text":"    /// see `xread_options`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREAD STREAMS key_1 key_2 ... key_N ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xread<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XREAD\").arg(\"STREAMS\").arg(keys).arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This method handles setting optional arguments for","highlight_start":1,"highlight_end":1},{"text":"    /// `XREAD` or `XREADGROUP` Redis commands.","highlight_start":1,"highlight_end":1},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Connection,RedisResult,Commands};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::streams::{StreamReadOptions,StreamReadReply};","highlight_start":1,"highlight_end":1},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":1},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Read 10 messages from the start of the stream,","highlight_start":1,"highlight_end":1},{"text":"    /// // without registering as a consumer group.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":1},{"text":"    ///     .count(10);","highlight_start":1,"highlight_end":1},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":1},{"text":"    ///     con.xread_options(&[\"k1\"], &[\"0\"], &opts);","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Read all undelivered messages for a given","highlight_start":1,"highlight_end":1},{"text":"    /// // consumer group. Be advised: the consumer group must already","highlight_start":1,"highlight_end":1},{"text":"    /// // exist before making this call. Also note: we're passing","highlight_start":1,"highlight_end":1},{"text":"    /// // '>' as the id here, which means all undelivered messages.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":1},{"text":"    ///     .group(\"group-1\", \"consumer-1\");","highlight_start":1,"highlight_end":1},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":1},{"text":"    ///     con.xread_options(&[\"k1\"], &[\">\"], &opts);","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREAD [BLOCK <milliseconds>] [COUNT <count>]","highlight_start":1,"highlight_end":1},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":1},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// XREADGROUP [GROUP group-name consumer-name] [BLOCK <milliseconds>] [COUNT <count>] [NOACK] ","highlight_start":1,"highlight_end":1},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":1},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xread_options<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":1},{"text":"        options: &'a streams::StreamReadOptions","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if options.read_only() {","highlight_start":1,"highlight_end":1},{"text":"            \"XREAD\"","highlight_start":1,"highlight_end":1},{"text":"        } else {","highlight_start":1,"highlight_end":1},{"text":"            \"XREADGROUP\"","highlight_start":1,"highlight_end":1},{"text":"        })","highlight_start":1,"highlight_end":1},{"text":"        .arg(options)","highlight_start":1,"highlight_end":1},{"text":"        .arg(\"STREAMS\")","highlight_start":1,"highlight_end":1},{"text":"        .arg(keys)","highlight_start":1,"highlight_end":1},{"text":"        .arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange`.","highlight_start":1,"highlight_end":1},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREVRANGE key end start","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrevrange<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        start: S","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(end).arg(start)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_all`.","highlight_start":1,"highlight_end":1},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREVRANGE key + -","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    fn xrevrange_all<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(\"+\").arg(\"-\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_count`.","highlight_start":1,"highlight_end":1},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREVRANGE key end start [COUNT <n>]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrevrange_count<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        count: C","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XREVRANGE\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(end)","highlight_start":1,"highlight_end":1},{"text":"            .arg(start)","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim a stream `key` to a MAXLEN count.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XTRIM <key> MAXLEN [~|=] <count>  (Same as XADD MAXLEN option)","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xtrim<K: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        maxlen: streams::StreamMaxlen","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XTRIM\").arg(key).arg(maxlen)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"implement_commands!","def_site_span":{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/commands/macros.rs","byte_start":0,"byte_end":31,"line_start":1,"line_end":1,"column_start":1,"column_end":32,"is_primary":false,"text":[{"text":"macro_rules! implement_commands {","highlight_start":1,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"trait `AsyncCommands` which provides `get` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use redis::AsyncCommands;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `get` found for mutable reference `&mut ConnectionManager` in the current scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:92:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m91\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let value: Option<String> = conn\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m_____________________________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .get(&key).await\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `hget` with a similar name, but with different arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/commands/mod.rs:41:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimplement_commands! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    'a\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // most common operations\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1872\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1873\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `implement_commands` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `AsyncCommands` which provides `get` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[38;5;10m+ use redis::AsyncCommands;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":3970,"byte_end":3978,"line_start":113,"line_end":113,"column_start":36,"column_end":44,"is_primary":true,"text":[{"text":"            return Err(RedisError::Prepared(\"Missing key or field for HGET command\".to_string()));","highlight_start":36,"highlight_end":44}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:113:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            return Err(RedisError::Prepared(\"Missing key or field for HGET command\".to_string()));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `hget` found for mutable reference `&mut ConnectionManager` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":4195,"byte_end":4213,"line_start":118,"line_end":119,"column_start":37,"column_end":14,"is_primary":false,"text":[{"text":"        let value: Option<String> = conn","highlight_start":37,"highlight_end":41},{"text":"            .hget(&key, &field).await","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/prepared.rs","byte_start":4213,"byte_end":4217,"line_start":119,"line_end":119,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"            .hget(&key, &field).await","highlight_start":14,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"there is a method `get` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/commands/macros.rs","byte_start":6752,"byte_end":7021,"line_start":162,"line_end":167,"column_start":17,"column_end":40,"is_primary":true,"text":[{"text":"                fn $name<$lifetime, $($tyargs: $ty + Send + Sync + $lifetime,)* RV>(","highlight_start":17,"highlight_end":85},{"text":"                    & $lifetime mut self","highlight_start":1,"highlight_end":41},{"text":"                    $(, $argname: $argty)*","highlight_start":1,"highlight_end":43},{"text":"                ) -> crate::types::RedisFuture<'a, RV>","highlight_start":1,"highlight_end":55},{"text":"                where","highlight_start":1,"highlight_end":22},{"text":"                    RV: FromRedisValue,","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/commands/mod.rs","byte_start":2151,"byte_end":65818,"line_start":41,"line_end":1873,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"implement_commands! {","highlight_start":1,"highlight_end":22},{"text":"    'a","highlight_start":1,"highlight_end":7},{"text":"    // most common operations","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key.  If key is a vec this becomes an `MGET`.","highlight_start":1,"highlight_end":73},{"text":"    fn get<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":37},{"text":"        cmd(if key.is_single_arg() { \"GET\" } else { \"MGET\" }).arg(key)","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get values of keys","highlight_start":1,"highlight_end":27},{"text":"    fn mget<K: ToRedisArgs>(key: K){","highlight_start":1,"highlight_end":37},{"text":"        cmd(\"MGET\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all keys matching pattern","highlight_start":1,"highlight_end":39},{"text":"    fn keys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"KEYS\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key.","highlight_start":1,"highlight_end":39},{"text":"    fn set<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":63},{"text":"        cmd(\"SET\").arg(key).arg(value)","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key with options.","highlight_start":1,"highlight_end":52},{"text":"    fn set_options<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: SetOptions) {","highlight_start":1,"highlight_end":92},{"text":"        cmd(\"SET\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":44},{"text":"    #[allow(deprecated)]","highlight_start":1,"highlight_end":25},{"text":"    #[deprecated(since = \"0.22.4\", note = \"Renamed to mset() to reflect Redis name\")]","highlight_start":1,"highlight_end":86},{"text":"    fn set_multiple<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":75},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":44},{"text":"    fn mset<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration of a key.","highlight_start":1,"highlight_end":47},{"text":"    fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, seconds: u64) {","highlight_start":1,"highlight_end":80},{"text":"        cmd(\"SETEX\").arg(key).arg(seconds).arg(value)","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration in milliseconds of a key.","highlight_start":1,"highlight_end":63},{"text":"    fn pset_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, milliseconds: u64) {","highlight_start":1,"highlight_end":86},{"text":"        cmd(\"PSETEX\").arg(key).arg(milliseconds).arg(value)","highlight_start":1,"highlight_end":60},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value of a key, only if the key does not exist","highlight_start":1,"highlight_end":63},{"text":"    fn set_nx<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"SETNX\").arg(key).arg(value)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values failing if at least one already exists.","highlight_start":1,"highlight_end":83},{"text":"    fn mset_nx<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"MSETNX\").arg(items)","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key and return its old value.","highlight_start":1,"highlight_end":64},{"text":"    fn getset<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"GETSET\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get a range of bytes/substring from the value of a key. Negative values provide an offset from the end of the value.","highlight_start":1,"highlight_end":125},{"text":"    fn getrange<K: ToRedisArgs>(key: K, from: isize, to: isize) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"GETRANGE\").arg(key).arg(from).arg(to)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Overwrite the part of the value stored in key at the specified offset.","highlight_start":1,"highlight_end":79},{"text":"    fn setrange<K: ToRedisArgs, V: ToRedisArgs>(key: K, offset: isize, value: V) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"SETRANGE\").arg(key).arg(offset).arg(value)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete one or more keys.","highlight_start":1,"highlight_end":33},{"text":"    fn del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":37},{"text":"        cmd(\"DEL\").arg(key)","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a key exists.","highlight_start":1,"highlight_end":35},{"text":"    fn exists<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"EXISTS\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the type of a key.","highlight_start":1,"highlight_end":37},{"text":"    fn key_type<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"TYPE\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in seconds.","highlight_start":1,"highlight_end":45},{"text":"    fn expire<K: ToRedisArgs>(key: K, seconds: i64) {","highlight_start":1,"highlight_end":54},{"text":"        cmd(\"EXPIRE\").arg(key).arg(seconds)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp.","highlight_start":1,"highlight_end":58},{"text":"    fn expire_at<K: ToRedisArgs>(key: K, ts: i64) {","highlight_start":1,"highlight_end":52},{"text":"        cmd(\"EXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in milliseconds.","highlight_start":1,"highlight_end":50},{"text":"    fn pexpire<K: ToRedisArgs>(key: K, ms: i64) {","highlight_start":1,"highlight_end":50},{"text":"        cmd(\"PEXPIRE\").arg(key).arg(ms)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp in milliseconds.","highlight_start":1,"highlight_end":74},{"text":"    fn pexpire_at<K: ToRedisArgs>(key: K, ts: i64) {","highlight_start":1,"highlight_end":53},{"text":"        cmd(\"PEXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove the expiration from a key.","highlight_start":1,"highlight_end":42},{"text":"    fn persist<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"PERSIST\").arg(key)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key.","highlight_start":1,"highlight_end":42},{"text":"    fn ttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":37},{"text":"        cmd(\"TTL\").arg(key)","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key in milliseconds.","highlight_start":1,"highlight_end":58},{"text":"    fn pttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"PTTL\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and set expiration","highlight_start":1,"highlight_end":50},{"text":"    fn get_ex<K: ToRedisArgs>(key: K, expire_at: Expiry) {","highlight_start":1,"highlight_end":59},{"text":"        let (option, time_arg) = match expire_at {","highlight_start":1,"highlight_end":51},{"text":"            Expiry::EX(sec) => (\"EX\", Some(sec)),","highlight_start":1,"highlight_end":50},{"text":"            Expiry::PX(ms) => (\"PX\", Some(ms)),","highlight_start":1,"highlight_end":48},{"text":"            Expiry::EXAT(timestamp_sec) => (\"EXAT\", Some(timestamp_sec)),","highlight_start":1,"highlight_end":74},{"text":"            Expiry::PXAT(timestamp_ms) => (\"PXAT\", Some(timestamp_ms)),","highlight_start":1,"highlight_end":72},{"text":"            Expiry::PERSIST => (\"PERSIST\", None),","highlight_start":1,"highlight_end":50},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETEX\").arg(key).arg(option).arg(time_arg)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and delete it","highlight_start":1,"highlight_end":45},{"text":"    fn get_del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"GETDEL\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key.","highlight_start":1,"highlight_end":22},{"text":"    fn rename<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"RENAME\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key, only if the new key does not exist.","highlight_start":1,"highlight_end":58},{"text":"    fn rename_nx<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":71},{"text":"        cmd(\"RENAMENX\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unlink one or more keys.","highlight_start":1,"highlight_end":33},{"text":"    fn unlink<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"UNLINK\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // common string operations","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Append a value to a key.","highlight_start":1,"highlight_end":33},{"text":"    fn append<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"APPEND\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increment the numeric value of a key by the given amount.  This","highlight_start":1,"highlight_end":72},{"text":"    /// issues a `INCRBY` or `INCRBYFLOAT` depending on the type.","highlight_start":1,"highlight_end":66},{"text":"    fn incr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":85},{"text":"            \"INCRBYFLOAT\"","highlight_start":1,"highlight_end":26},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            \"INCRBY\"","highlight_start":1,"highlight_end":21},{"text":"        }).arg(key).arg(delta)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Decrement the numeric value of a key by the given amount.","highlight_start":1,"highlight_end":66},{"text":"    fn decr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"DECRBY\").arg(key).arg(delta)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets or clears the bit at offset in the string value stored at key.","highlight_start":1,"highlight_end":76},{"text":"    fn setbit<K: ToRedisArgs>(key: K, offset: usize, value: bool) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"SETBIT\").arg(key).arg(offset).arg(i32::from(value))","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the bit value at offset in the string value stored at key.","highlight_start":1,"highlight_end":75},{"text":"    fn getbit<K: ToRedisArgs>(key: K, offset: usize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"GETBIT\").arg(key).arg(offset)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string.","highlight_start":1,"highlight_end":36},{"text":"    fn bitcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"BITCOUNT\").arg(key)","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string in a range.","highlight_start":1,"highlight_end":47},{"text":"    fn bitcount_range<K: ToRedisArgs>(key: K, start: usize, end: usize) {","highlight_start":1,"highlight_end":74},{"text":"        cmd(\"BITCOUNT\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise AND between multiple keys (containing string values)","highlight_start":1,"highlight_end":79},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_and<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"BITOP\").arg(\"AND\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise OR between multiple keys (containing string values)","highlight_start":1,"highlight_end":78},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_or<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":71},{"text":"        cmd(\"BITOP\").arg(\"OR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise XOR between multiple keys (containing string values)","highlight_start":1,"highlight_end":79},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_xor<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"BITOP\").arg(\"XOR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise NOT of the key (containing string values)","highlight_start":1,"highlight_end":68},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_not<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckey: S) {","highlight_start":1,"highlight_end":71},{"text":"        cmd(\"BITOP\").arg(\"NOT\").arg(dstkey).arg(srckey)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the length of the value stored in a key.","highlight_start":1,"highlight_end":53},{"text":"    fn strlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"STRLEN\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hash operations","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":56},{"text":"    fn hget<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(if field.is_single_arg() { \"HGET\" } else { \"HMGET\" }).arg(key).arg(field)","highlight_start":1,"highlight_end":86},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":59},{"text":"    fn hdel<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"HDEL\").arg(key).arg(field)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash.","highlight_start":1,"highlight_end":39},{"text":"    fn hset<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":90},{"text":"        cmd(\"HSET\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash if it does not exist.","highlight_start":1,"highlight_end":60},{"text":"    fn hset_nx<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":93},{"text":"        cmd(\"HSETNX\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a multiple fields in a hash.","highlight_start":1,"highlight_end":42},{"text":"    fn hset_multiple<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, items: &'a [(F, V)]) {","highlight_start":1,"highlight_end":100},{"text":"        cmd(\"HMSET\").arg(key).arg(items)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments a value.","highlight_start":1,"highlight_end":28},{"text":"    fn hincr<K: ToRedisArgs, F: ToRedisArgs, D: ToRedisArgs>(key: K, field: F, delta: D) {","highlight_start":1,"highlight_end":91},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":85},{"text":"            \"HINCRBYFLOAT\"","highlight_start":1,"highlight_end":27},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            \"HINCRBY\"","highlight_start":1,"highlight_end":22},{"text":"        }).arg(key).arg(field).arg(delta)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Checks if a field in a hash exists.","highlight_start":1,"highlight_end":44},{"text":"    fn hexists<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"HEXISTS\").arg(key).arg(field)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the keys in a hash.","highlight_start":1,"highlight_end":37},{"text":"    fn hkeys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"HKEYS\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the values in a hash.","highlight_start":1,"highlight_end":39},{"text":"    fn hvals<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"HVALS\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the fields and values in a hash.","highlight_start":1,"highlight_end":50},{"text":"    fn hgetall<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"HGETALL\").arg(key)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets the length of a hash.","highlight_start":1,"highlight_end":35},{"text":"    fn hlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"HLEN\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // list operations","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element from a list, push it to another list","highlight_start":1,"highlight_end":60},{"text":"    /// and return it; or block until one is available","highlight_start":1,"highlight_end":55},{"text":"    fn blmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction, timeout: f64) {","highlight_start":1,"highlight_end":124},{"text":"        cmd(\"BLMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir).arg(timeout)","highlight_start":1,"highlight_end":85},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":81},{"text":"    /// provided key names; or blocks until one is available.","highlight_start":1,"highlight_end":62},{"text":"    fn blmpop<K: ToRedisArgs>(timeout: f64, numkeys: usize, key: K, dir: Direction, count: usize){","highlight_start":1,"highlight_end":99},{"text":"        cmd(\"BLMPOP\").arg(timeout).arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":90},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the first element in a list, or block until one is available.","highlight_start":1,"highlight_end":85},{"text":"    fn blpop<K: ToRedisArgs>(key: K, timeout: f64) {","highlight_start":1,"highlight_end":53},{"text":"        cmd(\"BLPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the last element in a list, or block until one is available.","highlight_start":1,"highlight_end":84},{"text":"    fn brpop<K: ToRedisArgs>(key: K, timeout: f64) {","highlight_start":1,"highlight_end":53},{"text":"        cmd(\"BRPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it;","highlight_start":1,"highlight_end":72},{"text":"    /// or block until one is available.","highlight_start":1,"highlight_end":41},{"text":"    fn brpoplpush<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, timeout: f64) {","highlight_start":1,"highlight_end":88},{"text":"        cmd(\"BRPOPLPUSH\").arg(srckey).arg(dstkey).arg(timeout)","highlight_start":1,"highlight_end":63},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get an element from a list by its index.","highlight_start":1,"highlight_end":49},{"text":"    fn lindex<K: ToRedisArgs>(key: K, index: isize) {","highlight_start":1,"highlight_end":54},{"text":"        cmd(\"LINDEX\").arg(key).arg(index)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element before another element in a list.","highlight_start":1,"highlight_end":60},{"text":"    fn linsert_before<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":71},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"BEFORE\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":68},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element after another element in a list.","highlight_start":1,"highlight_end":59},{"text":"    fn linsert_after<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":70},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"AFTER\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":67},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the length of the list stored at key.","highlight_start":1,"highlight_end":54},{"text":"    fn llen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"LLEN\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element a list, push it to another list and return it","highlight_start":1,"highlight_end":69},{"text":"    fn lmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction) {","highlight_start":1,"highlight_end":109},{"text":"        cmd(\"LMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir)","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":81},{"text":"    /// provided key names.","highlight_start":1,"highlight_end":28},{"text":"    fn lmpop<K: ToRedisArgs>( numkeys: usize, key: K, dir: Direction, count: usize) {","highlight_start":1,"highlight_end":86},{"text":"        cmd(\"LMPOP\").arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":76},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` first elements of the list stored at key.","highlight_start":1,"highlight_end":88},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If `count` is not specified, then defaults to first element.","highlight_start":1,"highlight_end":69},{"text":"    fn lpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"LPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the index of the first matching value of the list stored at key.","highlight_start":1,"highlight_end":81},{"text":"    fn lpos<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: LposOptions) {","highlight_start":1,"highlight_end":86},{"text":"        cmd(\"LPOS\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the head of the list stored at key.","highlight_start":1,"highlight_end":79},{"text":"    fn lpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"LPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts a value at the head of the list stored at key, only if key","highlight_start":1,"highlight_end":75},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":41},{"text":"    fn lpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"LPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the specified elements of the list stored at key.","highlight_start":1,"highlight_end":66},{"text":"    fn lrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"LRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes the first count occurrences of elements equal to value","highlight_start":1,"highlight_end":71},{"text":"    /// from the list stored at key.","highlight_start":1,"highlight_end":37},{"text":"    fn lrem<K: ToRedisArgs, V: ToRedisArgs>(key: K, count: isize, value: V) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"LREM\").arg(key).arg(count).arg(value)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim an existing list so that it will contain only the specified","highlight_start":1,"highlight_end":73},{"text":"    /// range of elements specified.","highlight_start":1,"highlight_end":37},{"text":"    fn ltrim<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"LTRIM\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets the list element at index to value","highlight_start":1,"highlight_end":48},{"text":"    fn lset<K: ToRedisArgs, V: ToRedisArgs>(key: K, index: isize, value: V) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"LSET\").arg(key).arg(index).arg(value)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` last elements of the list stored at key","highlight_start":1,"highlight_end":86},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If `count` is not specified, then defaults to last element.","highlight_start":1,"highlight_end":68},{"text":"    fn rpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"RPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it.","highlight_start":1,"highlight_end":72},{"text":"    fn rpoplpush<K: ToRedisArgs, D: ToRedisArgs>(key: K, dstkey: D) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"RPOPLPUSH\").arg(key).arg(dstkey)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the tail of the list stored at key.","highlight_start":1,"highlight_end":79},{"text":"    fn rpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"RPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts value at the tail of the list stored at key, only if key","highlight_start":1,"highlight_end":73},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":41},{"text":"    fn rpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"RPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // set commands","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one or more members to a set.","highlight_start":1,"highlight_end":42},{"text":"    fn sadd<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"SADD\").arg(key).arg(member)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a set.","highlight_start":1,"highlight_end":44},{"text":"    fn scard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"SCARD\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets.","highlight_start":1,"highlight_end":32},{"text":"    fn sdiff<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"SDIFF\").arg(keys)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":69},{"text":"    fn sdiffstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"SDIFFSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets.","highlight_start":1,"highlight_end":33},{"text":"    fn sinter<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"SINTER\").arg(keys)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":70},{"text":"    fn sinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":73},{"text":"        cmd(\"SINTERSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a given value is a member of a set.","highlight_start":1,"highlight_end":57},{"text":"    fn sismember<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"SISMEMBER\").arg(key).arg(member)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get all the members in a set.","highlight_start":1,"highlight_end":38},{"text":"    fn smembers<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"SMEMBERS\").arg(key)","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Move a member from one set to another.","highlight_start":1,"highlight_end":47},{"text":"    fn smove<S: ToRedisArgs, D: ToRedisArgs, M: ToRedisArgs>(srckey: S, dstkey: D, member: M) {","highlight_start":1,"highlight_end":96},{"text":"        cmd(\"SMOVE\").arg(srckey).arg(dstkey).arg(member)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and return a random member from a set.","highlight_start":1,"highlight_end":54},{"text":"    fn spop<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"SPOP\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get one random member from a set.","highlight_start":1,"highlight_end":42},{"text":"    fn srandmember<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":45},{"text":"        cmd(\"SRANDMEMBER\").arg(key)","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get multiple random members from a set.","highlight_start":1,"highlight_end":48},{"text":"    fn srandmember_multiple<K: ToRedisArgs>(key: K, count: usize) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"SRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a set.","highlight_start":1,"highlight_end":47},{"text":"    fn srem<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"SREM\").arg(key).arg(member)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets.","highlight_start":1,"highlight_end":27},{"text":"    fn sunion<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"SUNION\").arg(keys)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":64},{"text":"    fn sunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":73},{"text":"        cmd(\"SUNIONSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // sorted set commands","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one member to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":82},{"text":"    fn zadd<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, member: M, score: S) {","highlight_start":1,"highlight_end":91},{"text":"        cmd(\"ZADD\").arg(key).arg(score).arg(member)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple members to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":88},{"text":"    fn zadd_multiple<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, items: &'a [(S, M)]) {","highlight_start":1,"highlight_end":100},{"text":"        cmd(\"ZADD\").arg(key).arg(items)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a sorted set.","highlight_start":1,"highlight_end":51},{"text":"    fn zcard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"ZCARD\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the members in a sorted set with scores within the given values.","highlight_start":1,"highlight_end":79},{"text":"    fn zcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":90},{"text":"        cmd(\"ZCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments the member in a sorted set at key by delta.","highlight_start":1,"highlight_end":63},{"text":"    /// If the member does not exist, it is added with delta as its score.","highlight_start":1,"highlight_end":75},{"text":"    fn zincr<K: ToRedisArgs, M: ToRedisArgs, D: ToRedisArgs>(key: K, member: M, delta: D) {","highlight_start":1,"highlight_end":92},{"text":"        cmd(\"ZINCRBY\").arg(key).arg(delta).arg(member)","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":77},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":79},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":77},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zinterstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":77},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zinterstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore`], but with the ability to specify a","highlight_start":1,"highlight_end":69},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zinterstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":108},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zinterstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zinterstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the number of members in a sorted set between a given lexicographical range.","highlight_start":1,"highlight_end":91},{"text":"    fn zlexcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":93},{"text":"        cmd(\"ZLEXCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the member with the highest score in a sorted set.","highlight_start":1,"highlight_end":79},{"text":"    /// Blocks until a member is available otherwise.","highlight_start":1,"highlight_end":54},{"text":"    fn bzpopmax<K: ToRedisArgs>(key: K, timeout: f64) {","highlight_start":1,"highlight_end":56},{"text":"        cmd(\"BZPOPMAX\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores in a sorted set","highlight_start":1,"highlight_end":88},{"text":"    fn zpopmax<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"ZPOPMAX\").arg(key).arg(count)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the member with the lowest score in a sorted set.","highlight_start":1,"highlight_end":78},{"text":"    /// Blocks until a member is available otherwise.","highlight_start":1,"highlight_end":54},{"text":"    fn bzpopmin<K: ToRedisArgs>(key: K, timeout: f64) {","highlight_start":1,"highlight_end":56},{"text":"        cmd(\"BZPOPMIN\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores in a sorted set","highlight_start":1,"highlight_end":87},{"text":"    fn zpopmin<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"ZPOPMIN\").arg(key).arg(count)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores,","highlight_start":1,"highlight_end":73},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":79},{"text":"    /// Blocks until a member is available otherwise.","highlight_start":1,"highlight_end":54},{"text":"    fn bzmpop_max<K: ToRedisArgs>(timeout: f64, keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":79},{"text":"        cmd(\"BZMPOP\").arg(timeout).arg(keys.len()).arg(keys).arg(\"MAX\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":96},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores,","highlight_start":1,"highlight_end":73},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":79},{"text":"    fn zmpop_max<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MAX\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":82},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores,","highlight_start":1,"highlight_end":72},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":79},{"text":"    /// Blocks until a member is available otherwise.","highlight_start":1,"highlight_end":54},{"text":"    fn bzmpop_min<K: ToRedisArgs>(timeout: f64, keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":79},{"text":"        cmd(\"BZMPOP\").arg(timeout).arg(keys.len()).arg(keys).arg(\"MIN\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":96},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores,","highlight_start":1,"highlight_end":72},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":79},{"text":"    fn zmpop_min<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MIN\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":82},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set (or 1 if `count == None`)","highlight_start":1,"highlight_end":84},{"text":"    fn zrandmember<K: ToRedisArgs>(key: K, count: Option<isize>) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set with scores","highlight_start":1,"highlight_end":70},{"text":"    fn zrandmember_withscores<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index","highlight_start":1,"highlight_end":60},{"text":"    fn zrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index with scores.","highlight_start":1,"highlight_end":73},{"text":"    fn zrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":70},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":77},{"text":"    fn zrangebylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":95},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":70},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":37},{"text":"    fn zrangebylex_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(","highlight_start":1,"highlight_end":75},{"text":"            key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":90},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":77},{"text":"    fn zrevrangebylex<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":98},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":70},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":37},{"text":"    fn zrevrangebylex_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":78},{"text":"            key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":61},{"text":"    fn zrangebyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":97},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":73},{"text":"    fn zrangebyscore_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":108},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":74},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":72},{"text":"    fn zrangebyscore_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":76},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":92},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":84},{"text":"    fn zrangebyscore_limit_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":87},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":74},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set.","highlight_start":1,"highlight_end":57},{"text":"    fn zrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"ZRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a sorted set.","highlight_start":1,"highlight_end":54},{"text":"    fn zrem<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"ZREM\").arg(key).arg(members)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set between the given lexicographical range.","highlight_start":1,"highlight_end":84},{"text":"    fn zrembylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":93},{"text":"        cmd(\"ZREMRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given indexes.","highlight_start":1,"highlight_end":69},{"text":"    fn zremrangebyrank<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":76},{"text":"        cmd(\"ZREMRANGEBYRANK\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given scores.","highlight_start":1,"highlight_end":68},{"text":"    fn zrembyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":95},{"text":"        cmd(\"ZREMRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":73},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":34},{"text":"    fn zrevrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":73},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":34},{"text":"    fn zrevrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":81},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":73},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":61},{"text":"    fn zrevrangebyscore<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":100},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":73},{"text":"    fn zrevrangebyscore_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":111},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":77},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":72},{"text":"    fn zrevrangebyscore_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":79},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":95},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":84},{"text":"    fn zrevrangebyscore_limit_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":90},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":77},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set, with scores ordered from high to low.","highlight_start":1,"highlight_end":95},{"text":"    fn zrevrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZREVRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the score associated with the given member in a sorted set.","highlight_start":1,"highlight_end":72},{"text":"    fn zscore<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"ZSCORE\").arg(key).arg(member)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the scores associated with multiple members in a sorted set.","highlight_start":1,"highlight_end":73},{"text":"    fn zscore_multiple<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: &'a [M]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZMSCORE\").arg(key).arg(members)","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":74},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":79},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":74},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zunionstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":74},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zunionstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore`], but with the ability to specify a","highlight_start":1,"highlight_end":69},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zunionstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":108},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zunionstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zunionstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hyperloglog commands","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified elements to the specified HyperLogLog.","highlight_start":1,"highlight_end":66},{"text":"    fn pfadd<K: ToRedisArgs, E: ToRedisArgs>(key: K, element: E) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"PFADD\").arg(key).arg(element)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the approximated cardinality of the set(s) observed by the","highlight_start":1,"highlight_end":74},{"text":"    /// HyperLogLog at key(s).","highlight_start":1,"highlight_end":31},{"text":"    fn pfcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"PFCOUNT\").arg(key)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Merge N different HyperLogLogs into a single one.","highlight_start":1,"highlight_end":58},{"text":"    fn pfmerge<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"PFMERGE\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Posts a message to the given channel.","highlight_start":1,"highlight_end":46},{"text":"    fn publish<K: ToRedisArgs, E: ToRedisArgs>(channel: K, message: E) {","highlight_start":1,"highlight_end":73},{"text":"        cmd(\"PUBLISH\").arg(channel).arg(message)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Object commands","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the encoding of a key.","highlight_start":1,"highlight_end":39},{"text":"    fn object_encoding<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":49},{"text":"        cmd(\"OBJECT\").arg(\"ENCODING\").arg(key)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the time in seconds since the last access of a key.","highlight_start":1,"highlight_end":68},{"text":"    fn object_idletime<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":49},{"text":"        cmd(\"OBJECT\").arg(\"IDLETIME\").arg(key)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the logarithmic access frequency counter of a key.","highlight_start":1,"highlight_end":67},{"text":"    fn object_freq<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":45},{"text":"        cmd(\"OBJECT\").arg(\"FREQ\").arg(key)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the reference count of a key.","highlight_start":1,"highlight_end":46},{"text":"    fn object_refcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":49},{"text":"        cmd(\"OBJECT\").arg(\"REFCOUNT\").arg(key)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // ACL commands","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":70},{"text":"    /// configuration option), this command will reload the ACLs from the file,","highlight_start":1,"highlight_end":80},{"text":"    /// replacing all the current ACL rules with the ones defined in the file.","highlight_start":1,"highlight_end":79},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_load<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"LOAD\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":70},{"text":"    /// configuration option), this command will save the currently defined","highlight_start":1,"highlight_end":76},{"text":"    /// ACLs from the server memory to the ACL file.","highlight_start":1,"highlight_end":53},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_save<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"SAVE\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the currently active ACL rules in the Redis server.","highlight_start":1,"highlight_end":66},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_list<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"LIST\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of all the usernames of the currently configured users in","highlight_start":1,"highlight_end":79},{"text":"    /// the Redis ACL system.","highlight_start":1,"highlight_end":30},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_users<>() {","highlight_start":1,"highlight_end":23},{"text":"        cmd(\"ACL\").arg(\"USERS\")","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all the rules defined for an existing ACL user.","highlight_start":1,"highlight_end":64},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_getuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":50},{"text":"        cmd(\"ACL\").arg(\"GETUSER\").arg(username)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user without any privilege.","highlight_start":1,"highlight_end":51},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_setuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":50},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user with the specified rules or modify the rules of","highlight_start":1,"highlight_end":76},{"text":"    /// an existing user.","highlight_start":1,"highlight_end":26},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_setuser_rules<K: ToRedisArgs>(username: K, rules: &'a [acl::Rule]) {","highlight_start":1,"highlight_end":80},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username).arg(rules)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete all the specified ACL users and terminate all the connections","highlight_start":1,"highlight_end":77},{"text":"    /// that are authenticated with such users.","highlight_start":1,"highlight_end":48},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_deluser<K: ToRedisArgs>(usernames: &'a [K]) {","highlight_start":1,"highlight_end":57},{"text":"        cmd(\"ACL\").arg(\"DELUSER\").arg(usernames)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the available ACL categories.","highlight_start":1,"highlight_end":44},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_cat<>() {","highlight_start":1,"highlight_end":21},{"text":"        cmd(\"ACL\").arg(\"CAT\")","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows all the Redis commands in the specified category.","highlight_start":1,"highlight_end":64},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_cat_categoryname<K: ToRedisArgs>(categoryname: K) {","highlight_start":1,"highlight_end":63},{"text":"        cmd(\"ACL\").arg(\"CAT\").arg(categoryname)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 256-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":79},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_genpass<>() {","highlight_start":1,"highlight_end":25},{"text":"        cmd(\"ACL\").arg(\"GENPASS\")","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 1-to-1024-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":85},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_genpass_bits<>(bits: isize) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"ACL\").arg(\"GENPASS\").arg(bits)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the username the current connection is authenticated with.","highlight_start":1,"highlight_end":75},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_whoami<>() {","highlight_start":1,"highlight_end":24},{"text":"        cmd(\"ACL\").arg(\"WHOAMI\")","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of recent ACL security events","highlight_start":1,"highlight_end":51},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_log<>(count: isize) {","highlight_start":1,"highlight_end":33},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(count)","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Clears the ACL log.","highlight_start":1,"highlight_end":28},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_log_reset<>() {","highlight_start":1,"highlight_end":27},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(\"RESET\")","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a helpful text describing the different subcommands.","highlight_start":1,"highlight_end":69},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_help<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"HELP\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // geospatial commands","highlight_start":1,"highlight_end":27},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified geospatial items to the specified key.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every member has to be written as a tuple of `(longitude, latitude,","highlight_start":1,"highlight_end":76},{"text":"    /// member_name)`. It can be a single tuple, or a vector of tuples.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `longitude, latitude` can be set using [`redis::geo::Coord`][1].","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Returns the number of elements added to the sorted set, not including","highlight_start":1,"highlight_end":78},{"text":"    /// elements already existing for which the score was updated.","highlight_start":1,"highlight_end":67},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, Connection, RedisResult};","highlight_start":1,"highlight_end":56},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn add_point(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":67},{"text":"    ///     con.geo_add(\"my_gis\", (Coord::lon_lat(13.361389, 38.115556), \"Palermo\"))","highlight_start":1,"highlight_end":85},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn add_point_with_tuples(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":79},{"text":"    ///     con.geo_add(\"my_gis\", (\"13.361389\", \"38.115556\", \"Palermo\"))","highlight_start":1,"highlight_end":73},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn add_many_points(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":73},{"text":"    ///     con.geo_add(\"my_gis\", &[","highlight_start":1,"highlight_end":37},{"text":"    ///         (\"13.361389\", \"38.115556\", \"Palermo\"),","highlight_start":1,"highlight_end":55},{"text":"    ///         (\"15.087269\", \"37.502669\", \"Catania\")","highlight_start":1,"highlight_end":54},{"text":"    ///     ])","highlight_start":1,"highlight_end":15},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_add<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"GEOADD\").arg(key).arg(members)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the distance between two members in the geospatial index","highlight_start":1,"highlight_end":72},{"text":"    /// represented by the sorted set.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If one or both the members are missing, the command returns NULL, so","highlight_start":1,"highlight_end":77},{"text":"    /// it may be convenient to parse its response as either `Option<f64>` or","highlight_start":1,"highlight_end":78},{"text":"    /// `Option<String>`.","highlight_start":1,"highlight_end":26},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    /// use redis::geo::Unit;","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn get_dists(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":52},{"text":"    ///     let x: RedisResult<f64> = con.geo_dist(","highlight_start":1,"highlight_end":52},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":26},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":27},{"text":"    ///         \"Catania\",","highlight_start":1,"highlight_end":27},{"text":"    ///         Unit::Kilometers","highlight_start":1,"highlight_end":33},{"text":"    ///     );","highlight_start":1,"highlight_end":15},{"text":"    ///     // x is Ok(166.2742)","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     let x: RedisResult<Option<f64>> = con.geo_dist(","highlight_start":1,"highlight_end":60},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":26},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":27},{"text":"    ///         \"Atlantis\",","highlight_start":1,"highlight_end":28},{"text":"    ///         Unit::Meters","highlight_start":1,"highlight_end":29},{"text":"    ///     );","highlight_start":1,"highlight_end":15},{"text":"    ///     // x is Ok(None)","highlight_start":1,"highlight_end":29},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_dist<K: ToRedisArgs, M1: ToRedisArgs, M2: ToRedisArgs>(","highlight_start":1,"highlight_end":67},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        member1: M1,","highlight_start":1,"highlight_end":21},{"text":"        member2: M2,","highlight_start":1,"highlight_end":21},{"text":"        unit: geo::Unit","highlight_start":1,"highlight_end":24},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"GEODIST\")","highlight_start":1,"highlight_end":23},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(member1)","highlight_start":1,"highlight_end":26},{"text":"            .arg(member2)","highlight_start":1,"highlight_end":26},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return valid [Geohash][1] strings representing the position of one or","highlight_start":1,"highlight_end":78},{"text":"    /// more members of the geospatial index represented by the sorted set at","highlight_start":1,"highlight_end":78},{"text":"    /// key.","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: https://en.wikipedia.org/wiki/Geohash","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn get_hash(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":51},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", \"Palermo\");","highlight_start":1,"highlight_end":81},{"text":"    ///     // x is vec![\"sqc8b49rny0\"]","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":95},{"text":"    ///     // x is vec![\"sqc8b49rny0\", \"sqdtr74hyu0\"]","highlight_start":1,"highlight_end":55},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_hash<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"GEOHASH\").arg(key).arg(members)","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the positions of all the specified members of the geospatial","highlight_start":1,"highlight_end":76},{"text":"    /// index represented by the sorted set at key.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every position is a pair of `(longitude, latitude)`. [`redis::geo::Coord`][1]","highlight_start":1,"highlight_end":86},{"text":"    /// can be used to convert these value in a struct.","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn get_position(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":55},{"text":"    ///     let x: RedisResult<Vec<Vec<f64>>> = con.geo_pos(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":96},{"text":"    ///     // x is [ [ 13.361389, 38.115556 ], [ 15.087269, 37.502669 ] ];","highlight_start":1,"highlight_end":76},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     let x: Vec<Coord<f64>> = con.geo_pos(\"my_gis\", \"Palermo\").unwrap();","highlight_start":1,"highlight_end":80},{"text":"    ///     // x[0].longitude is 13.361389","highlight_start":1,"highlight_end":43},{"text":"    ///     // x[0].latitude is 38.115556","highlight_start":1,"highlight_end":42},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_pos<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"GEOPOS\").arg(key).arg(members)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the members of a sorted set populated with geospatial information","highlight_start":1,"highlight_end":81},{"text":"    /// using [`geo_add`](#method.geo_add), which are within the borders of the area","highlight_start":1,"highlight_end":85},{"text":"    /// specified with the center location and the maximum distance from the center","highlight_start":1,"highlight_end":84},{"text":"    /// (the radius).","highlight_start":1,"highlight_end":22},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every item in the result can be read with [`redis::geo::RadiusSearchResult`][1],","highlight_start":1,"highlight_end":89},{"text":"    /// which support the multiple formats returned by `GEORADIUS`.","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: ./geo/struct.RadiusSearchResult.html","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    /// use redis::geo::{RadiusOptions, RadiusSearchResult, RadiusOrder, Unit};","highlight_start":1,"highlight_end":80},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn radius(con: &mut redis::Connection) -> Vec<RadiusSearchResult> {","highlight_start":1,"highlight_end":76},{"text":"    ///     let opts = RadiusOptions::default().with_dist().order(RadiusOrder::Asc);","highlight_start":1,"highlight_end":85},{"text":"    ///     con.geo_radius(\"my_gis\", 15.90, 37.21, 51.39, Unit::Kilometers, opts).unwrap()","highlight_start":1,"highlight_end":91},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_radius<K: ToRedisArgs>(","highlight_start":1,"highlight_end":35},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        longitude: f64,","highlight_start":1,"highlight_end":24},{"text":"        latitude: f64,","highlight_start":1,"highlight_end":23},{"text":"        radius: f64,","highlight_start":1,"highlight_end":21},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":25},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":36},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"GEORADIUS\")","highlight_start":1,"highlight_end":25},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(longitude)","highlight_start":1,"highlight_end":28},{"text":"            .arg(latitude)","highlight_start":1,"highlight_end":27},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":25},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":23},{"text":"            .arg(options)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Retrieve members selected by distance with the center of `member`. The","highlight_start":1,"highlight_end":79},{"text":"    /// member itself is always contained in the results.","highlight_start":1,"highlight_end":58},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_radius_by_member<K: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":61},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        member: M,","highlight_start":1,"highlight_end":19},{"text":"        radius: f64,","highlight_start":1,"highlight_end":21},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":25},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":36},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"GEORADIUSBYMEMBER\")","highlight_start":1,"highlight_end":33},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(member)","highlight_start":1,"highlight_end":25},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":25},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":23},{"text":"            .arg(options)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // streams commands","highlight_start":1,"highlight_end":24},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Ack pending stream messages checked out by a consumer.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XACK <key> <group> <id> <id> ... <id>","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xack<K: ToRedisArgs, G: ToRedisArgs, I: ToRedisArgs>(","highlight_start":1,"highlight_end":61},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        ids: &'a [I]) {","highlight_start":1,"highlight_end":24},{"text":"        cmd(\"XACK\")","highlight_start":1,"highlight_end":20},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message by `key`. Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":86},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":59},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd<K: ToRedisArgs, ID: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":78},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":28},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(items)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message by `key`.","highlight_start":1,"highlight_end":63},{"text":"    /// Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":47},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":68},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        map: BTM","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(map)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":82},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd_maxlen<","highlight_start":1,"highlight_end":20},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        ID: ToRedisArgs,","highlight_start":1,"highlight_end":25},{"text":"        F: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        V: ToRedisArgs","highlight_start":1,"highlight_end":23},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":39},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":28},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":20},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":25},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"            .arg(items)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":94},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":70},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd_maxlen_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":75},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":39},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        map: BTM","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":20},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":25},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"            .arg(map)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Claim pending, unacked messages, after some period of time,","highlight_start":1,"highlight_end":68},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method only accepts the must-have arguments for claiming messages.","highlight_start":1,"highlight_end":80},{"text":"    /// If optional arguments are required, see `xclaim_options` below.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> [<ID-1> <ID-2>]","highlight_start":1,"highlight_end":72},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xclaim<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs, MIT: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":98},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        consumer: C,","highlight_start":1,"highlight_end":21},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":28},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":22},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":32},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the optional arguments version for claiming unacked, pending messages","highlight_start":1,"highlight_end":86},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":18},{"text":"    /// use redis::{Connection,Commands,RedisResult};","highlight_start":1,"highlight_end":54},{"text":"    /// use redis::streams::{StreamClaimOptions,StreamClaimReply};","highlight_start":1,"highlight_end":67},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":74},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Claim all pending messages for key \"k1\",","highlight_start":1,"highlight_end":52},{"text":"    /// // from group \"g1\", checked out by consumer \"c1\"","highlight_start":1,"highlight_end":57},{"text":"    /// // for 10ms with RETRYCOUNT 2 and FORCE","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":49},{"text":"    ///     .with_force()","highlight_start":1,"highlight_end":26},{"text":"    ///     .retry(2);","highlight_start":1,"highlight_end":23},{"text":"    /// let results: RedisResult<StreamClaimReply> =","highlight_start":1,"highlight_end":53},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // All optional arguments return a `Result<StreamClaimReply>` with one exception:","highlight_start":1,"highlight_end":90},{"text":"    /// // Passing JUSTID returns only the message `id` and omits the HashMap for each message.","highlight_start":1,"highlight_end":96},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":49},{"text":"    ///     .with_justid();","highlight_start":1,"highlight_end":28},{"text":"    /// let results: RedisResult<Vec<String>> =","highlight_start":1,"highlight_end":48},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":68},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>","highlight_start":1,"highlight_end":70},{"text":"    ///     [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]","highlight_start":1,"highlight_end":71},{"text":"    ///     [FORCE] [JUSTID]","highlight_start":1,"highlight_end":29},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xclaim_options<","highlight_start":1,"highlight_end":23},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        MIT: ToRedisArgs,","highlight_start":1,"highlight_end":26},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":24},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        consumer: C,","highlight_start":1,"highlight_end":21},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":28},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":23},{"text":"        options: streams::StreamClaimOptions","highlight_start":1,"highlight_end":45},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":32},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":22},{"text":"            .arg(options)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a list of `id`s for a given stream `key`.","highlight_start":1,"highlight_end":58},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XDEL <key> [<ID1> <ID2> ... <IDN>]","highlight_start":1,"highlight_end":43},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xdel<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":46},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":22},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XDEL\").arg(key).arg(ids)","highlight_start":1,"highlight_end":38},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This command is used for creating a consumer `group`. It expects the stream key","highlight_start":1,"highlight_end":88},{"text":"    /// to already exist. Otherwise, use `xgroup_create_mkstream` if it doesn't.","highlight_start":1,"highlight_end":81},{"text":"    /// The `id` is the starting message id all consumers should read from. Use `$` If you want","highlight_start":1,"highlight_end":96},{"text":"    /// all consumers to read from the last message added to stream.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $>","highlight_start":1,"highlight_end":50},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_create<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":71},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        id: ID","highlight_start":1,"highlight_end":15},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":27},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the alternate version for creating a consumer `group`","highlight_start":1,"highlight_end":70},{"text":"    /// which makes the stream if it doesn't exist.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $> [MKSTREAM]","highlight_start":1,"highlight_end":61},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_create_mkstream<","highlight_start":1,"highlight_end":31},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":24},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        id: ID","highlight_start":1,"highlight_end":15},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":27},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"            .arg(\"MKSTREAM\")","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Alter which `id` you want consumers to begin reading from an existing","highlight_start":1,"highlight_end":78},{"text":"    /// consumer `group`.","highlight_start":1,"highlight_end":26},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":49},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_setid<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":70},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        id: ID","highlight_start":1,"highlight_end":15},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"SETID\")","highlight_start":1,"highlight_end":26},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Destroy an existing consumer `group` for a given stream `key`","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":49},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_destroy<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":55},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\").arg(\"DESTROY\").arg(key).arg(group)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This deletes a `consumer` from an existing consumer `group`","highlight_start":1,"highlight_end":68},{"text":"    /// for given stream `key.","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP DELCONSUMER <key> <groupname> <consumername>","highlight_start":1,"highlight_end":60},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_delconsumer<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":75},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        consumer: C","highlight_start":1,"highlight_end":20},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"DELCONSUMER\")","highlight_start":1,"highlight_end":32},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This returns all info details about","highlight_start":1,"highlight_end":44},{"text":"    /// which consumers have read messages for given consumer `group`.","highlight_start":1,"highlight_end":71},{"text":"    /// Take note of the StreamInfoConsumersReply return type.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":70},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XINFO CONSUMERS <key> <group>","highlight_start":1,"highlight_end":38},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xinfo_consumers<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":56},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XINFO\")","highlight_start":1,"highlight_end":21},{"text":"            .arg(\"CONSUMERS\")","highlight_start":1,"highlight_end":30},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all consumer `group`s created for a given stream `key`.","highlight_start":1,"highlight_end":72},{"text":"    /// Take note of the StreamInfoGroupsReply return type.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":70},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XINFO GROUPS <key>","highlight_start":1,"highlight_end":27},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xinfo_groups<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":46},{"text":"        cmd(\"XINFO\").arg(\"GROUPS\").arg(key)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns info about high-level stream details","highlight_start":1,"highlight_end":53},{"text":"    /// (first & last message `id`, length, number of groups, etc.)","highlight_start":1,"highlight_end":68},{"text":"    /// Take note of the StreamInfoStreamReply return type.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":70},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XINFO STREAM <key>","highlight_start":1,"highlight_end":27},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xinfo_stream<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":46},{"text":"        cmd(\"XINFO\").arg(\"STREAM\").arg(key)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the number of messages for a given stream `key`.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XLEN <key>","highlight_start":1,"highlight_end":19},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"XLEN\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is a basic version of making XPENDING command calls which only","highlight_start":1,"highlight_end":76},{"text":"    /// passes a stream `key` and consumer `group` and it","highlight_start":1,"highlight_end":58},{"text":"    /// returns details about which consumers have pending messages","highlight_start":1,"highlight_end":68},{"text":"    /// that haven't been acked.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// You can use this method along with","highlight_start":1,"highlight_end":43},{"text":"    /// `xclaim` or `xclaim_options` for determining which messages","highlight_start":1,"highlight_end":68},{"text":"    /// need to be retried.","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamPendingReply return type.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XPENDING <key> <group> [<start> <stop> <count> [<consumer>]]","highlight_start":1,"highlight_end":69},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xpending<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":49},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G","highlight_start":1,"highlight_end":17},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XPENDING\").arg(key).arg(group)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This XPENDING version returns a list of all messages over the range.","highlight_start":1,"highlight_end":77},{"text":"    /// You can use this for paginating pending messages (but without the message HashMap).","highlight_start":1,"highlight_end":92},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":76},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XPENDING <key> <group> <start> <stop> <count>","highlight_start":1,"highlight_end":54},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xpending_count<","highlight_start":1,"highlight_end":23},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        C: ToRedisArgs","highlight_start":1,"highlight_end":23},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        count: C","highlight_start":1,"highlight_end":17},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":24},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// An alternate version of `xpending_count` which filters by `consumer` name.","highlight_start":1,"highlight_end":83},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":76},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XPENDING <key> <group> <start> <stop> <count> <consumer>","highlight_start":1,"highlight_end":65},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xpending_consumer_count<","highlight_start":1,"highlight_end":32},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        CN: ToRedisArgs","highlight_start":1,"highlight_end":24},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        count: C,","highlight_start":1,"highlight_end":18},{"text":"        consumer: CN","highlight_start":1,"highlight_end":21},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":24},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a range of messages in a given stream `key`.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Set `start` to `-` to begin at the first message.","highlight_start":1,"highlight_end":58},{"text":"    /// Set `end` to `+` to end the most recent message.","highlight_start":1,"highlight_end":57},{"text":"    /// You can pass message `id` to both `start` and `end`.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamRangeReply return type.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XRANGE key start end","highlight_start":1,"highlight_end":29},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrange<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs>(","highlight_start":1,"highlight_end":63},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E","highlight_start":1,"highlight_end":15},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XRANGE\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A helper method for automatically returning all messages in a stream by `key`.","highlight_start":1,"highlight_end":87},{"text":"    /// **Use with caution!**","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XRANGE key - +","highlight_start":1,"highlight_end":23},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrange_all<K: ToRedisArgs>(key: K)  {","highlight_start":1,"highlight_end":45},{"text":"        cmd(\"XRANGE\").arg(key).arg(\"-\").arg(\"+\")","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A method for paginating a stream by `key`.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XRANGE key start end [COUNT <n>]","highlight_start":1,"highlight_end":41},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrange_count<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":85},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        count: C","highlight_start":1,"highlight_end":17},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XRANGE\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":26},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Read a list of `id`s for each stream `key`.","highlight_start":1,"highlight_end":52},{"text":"    /// This is the basic form of reading streams.","highlight_start":1,"highlight_end":51},{"text":"    /// For more advanced control, like blocking, limiting, or reading by consumer `group`,","highlight_start":1,"highlight_end":92},{"text":"    /// see `xread_options`.","highlight_start":1,"highlight_end":29},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREAD STREAMS key_1 key_2 ... key_N ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":63},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xread<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":47},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":23},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":22},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XREAD\").arg(\"STREAMS\").arg(keys).arg(ids)","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This method handles setting optional arguments for","highlight_start":1,"highlight_end":59},{"text":"    /// `XREAD` or `XREADGROUP` Redis commands.","highlight_start":1,"highlight_end":48},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":18},{"text":"    /// use redis::{Connection,RedisResult,Commands};","highlight_start":1,"highlight_end":54},{"text":"    /// use redis::streams::{StreamReadOptions,StreamReadReply};","highlight_start":1,"highlight_end":65},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":74},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Read 10 messages from the start of the stream,","highlight_start":1,"highlight_end":58},{"text":"    /// // without registering as a consumer group.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":48},{"text":"    ///     .count(10);","highlight_start":1,"highlight_end":24},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":52},{"text":"    ///     con.xread_options(&[\"k1\"], &[\"0\"], &opts);","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Read all undelivered messages for a given","highlight_start":1,"highlight_end":53},{"text":"    /// // consumer group. Be advised: the consumer group must already","highlight_start":1,"highlight_end":71},{"text":"    /// // exist before making this call. Also note: we're passing","highlight_start":1,"highlight_end":67},{"text":"    /// // '>' as the id here, which means all undelivered messages.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":48},{"text":"    ///     .group(\"group-1\", \"consumer-1\");","highlight_start":1,"highlight_end":45},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":52},{"text":"    ///     con.xread_options(&[\"k1\"], &[\">\"], &opts);","highlight_start":1,"highlight_end":55},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREAD [BLOCK <milliseconds>] [COUNT <count>]","highlight_start":1,"highlight_end":53},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":42},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// XREADGROUP [GROUP group-name consumer-name] [BLOCK <milliseconds>] [COUNT <count>] [NOACK] ","highlight_start":1,"highlight_end":100},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":42},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xread_options<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":55},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":23},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":23},{"text":"        options: &'a streams::StreamReadOptions","highlight_start":1,"highlight_end":48},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(if options.read_only() {","highlight_start":1,"highlight_end":37},{"text":"            \"XREAD\"","highlight_start":1,"highlight_end":20},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            \"XREADGROUP\"","highlight_start":1,"highlight_end":25},{"text":"        })","highlight_start":1,"highlight_end":11},{"text":"        .arg(options)","highlight_start":1,"highlight_end":22},{"text":"        .arg(\"STREAMS\")","highlight_start":1,"highlight_end":24},{"text":"        .arg(keys)","highlight_start":1,"highlight_end":19},{"text":"        .arg(ids)","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange`.","highlight_start":1,"highlight_end":49},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREVRANGE key end start","highlight_start":1,"highlight_end":32},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrevrange<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs>(","highlight_start":1,"highlight_end":66},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        start: S","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(end).arg(start)","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_all`.","highlight_start":1,"highlight_end":53},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREVRANGE key + -","highlight_start":1,"highlight_end":26},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    fn xrevrange_all<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":47},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(\"+\").arg(\"-\")","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_count`.","highlight_start":1,"highlight_end":55},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREVRANGE key end start [COUNT <n>]","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrevrange_count<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":88},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        count: C","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XREVRANGE\")","highlight_start":1,"highlight_end":25},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":26},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim a stream `key` to a MAXLEN count.","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XTRIM <key> MAXLEN [~|=] <count>  (Same as XADD MAXLEN option)","highlight_start":1,"highlight_end":71},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xtrim<K: ToRedisArgs>(","highlight_start":1,"highlight_end":30},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        maxlen: streams::StreamMaxlen","highlight_start":1,"highlight_end":38},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XTRIM\").arg(key).arg(maxlen)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"implement_commands!","def_site_span":{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/commands/macros.rs","byte_start":0,"byte_end":31,"line_start":1,"line_end":1,"column_start":1,"column_end":32,"is_primary":false,"text":[{"text":"macro_rules! implement_commands {","highlight_start":1,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"trait `AsyncCommands` which provides `hget` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use redis::AsyncCommands;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `hget` found for mutable reference `&mut ConnectionManager` in the current scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:119:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m118\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let value: Option<String> = conn\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m_____________________________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m119\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .hget(&key, &field).await\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `get` with a similar name, but with different arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/commands/mod.rs:41:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimplement_commands! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    'a\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // most common operations\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1872\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1873\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `implement_commands` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `AsyncCommands` which provides `hget` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[38;5;10m+ use redis::AsyncCommands;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":4855,"byte_end":4863,"line_start":141,"line_end":141,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"                RedisError::Prepared(\"Missing key, start, or stop for LRANGE command\".to_string())","highlight_start":29,"highlight_end":37}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:141:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m141\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                RedisError::Prepared(\"Missing key, start, or stop for LRANGE command\".to_string())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":5143,"byte_end":5151,"line_start":149,"line_end":149,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"            .map_err(|_| RedisError::Prepared(\"Invalid start index\".to_string()))?;","highlight_start":38,"highlight_end":46}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:149:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map_err(|_| RedisError::Prepared(\"Invalid start index\".to_string()))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":5324,"byte_end":5332,"line_start":153,"line_end":153,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"            .map_err(|_| RedisError::Prepared(\"Invalid stop index\".to_string()))?;","highlight_start":38,"highlight_end":46}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:153:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m153\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map_err(|_| RedisError::Prepared(\"Invalid stop index\".to_string()))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `lrange` found for mutable reference `&mut ConnectionManager` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":5405,"byte_end":5423,"line_start":155,"line_end":156,"column_start":35,"column_end":14,"is_primary":false,"text":[{"text":"        let values: Vec<String> = conn","highlight_start":35,"highlight_end":39},{"text":"            .lrange(&key, start, stop).await","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/prepared.rs","byte_start":5423,"byte_end":5429,"line_start":156,"line_end":156,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"            .lrange(&key, start, stop).await","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `AsyncCommands` which provides `lrange` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use redis::AsyncCommands;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `xrange` with a similar name","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":5423,"byte_end":5429,"line_start":156,"line_end":156,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"            .lrange(&key, start, stop).await","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":"xrange","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `lrange` found for mutable reference `&mut ConnectionManager` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:156:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let values: Vec<String> = conn\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m___________________________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .lrange(&key, start, stop).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `AsyncCommands` which provides `lrange` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use redis::AsyncCommands;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `xrange` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            .\u001b[0m\u001b[0m\u001b[38;5;10mxrange\u001b[0m\u001b[0m(&key, start, stop).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":6044,"byte_end":6052,"line_start":176,"line_end":176,"column_start":36,"column_end":44,"is_primary":true,"text":[{"text":"            return Err(RedisError::Prepared(\"Missing key for SMEMBERS command\".to_string()));","highlight_start":36,"highlight_end":44}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:176:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m176\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            return Err(RedisError::Prepared(\"Missing key for SMEMBERS command\".to_string()));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `smembers` found for mutable reference `&mut ConnectionManager` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":6204,"byte_end":6222,"line_start":180,"line_end":181,"column_start":35,"column_end":14,"is_primary":false,"text":[{"text":"        let values: Vec<String> = conn","highlight_start":35,"highlight_end":39},{"text":"            .smembers(&key).await","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/prepared.rs","byte_start":6222,"byte_end":6230,"line_start":181,"line_end":181,"column_start":14,"column_end":22,"is_primary":true,"text":[{"text":"            .smembers(&key).await","highlight_start":14,"highlight_end":22}],"label":"method not found in `&mut ConnectionManager`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `AsyncCommands` which provides `smembers` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use redis::AsyncCommands;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `smembers` found for mutable reference `&mut ConnectionManager` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:181:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m180\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let values: Vec<String> = conn\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m___________________________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m181\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .smembers(&key).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `&mut ConnectionManager`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `AsyncCommands` which provides `smembers` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use redis::AsyncCommands;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":6844,"byte_end":6852,"line_start":202,"line_end":202,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"                RedisError::Prepared(\"Missing key, start, or stop for ZRANGE command\".to_string())","highlight_start":29,"highlight_end":37}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:202:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                RedisError::Prepared(\"Missing key, start, or stop for ZRANGE command\".to_string())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":7132,"byte_end":7140,"line_start":210,"line_end":210,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"            .map_err(|_| RedisError::Prepared(\"Invalid start index\".to_string()))?;","highlight_start":38,"highlight_end":46}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:210:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map_err(|_| RedisError::Prepared(\"Invalid start index\".to_string()))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":7313,"byte_end":7321,"line_start":214,"line_end":214,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"            .map_err(|_| RedisError::Prepared(\"Invalid stop index\".to_string()))?;","highlight_start":38,"highlight_end":46}],"label":"variant or associated item not found in `RedisError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/error.rs","byte_start":101,"byte_end":120,"line_start":6,"line_end":6,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub enum RedisError {","highlight_start":1,"highlight_end":20}],"label":"variant or associated item `Prepared` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no variant or associated item named `Prepared` found for enum `error::RedisError` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:214:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m214\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .map_err(|_| RedisError::Prepared(\"Invalid stop index\".to_string()))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `RedisError`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/redis/src/error.rs:6:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum RedisError {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mvariant or associated item `Prepared` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `zrange` found for mutable reference `&mut ConnectionManager` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":7394,"byte_end":7412,"line_start":216,"line_end":217,"column_start":35,"column_end":14,"is_primary":false,"text":[{"text":"        let values: Vec<String> = conn","highlight_start":35,"highlight_end":39},{"text":"            .zrange(&key, start, stop).await","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/prepared.rs","byte_start":7412,"byte_end":7418,"line_start":217,"line_end":217,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"            .zrange(&key, start, stop).await","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `AsyncCommands` which provides `zrange` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use redis::AsyncCommands;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `lrange` with a similar name","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/prepared.rs","byte_start":7412,"byte_end":7418,"line_start":217,"line_end":217,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"            .zrange(&key, start, stop).await","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":"lrange","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `zrange` found for mutable reference `&mut ConnectionManager` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/prepared.rs:217:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m216\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let values: Vec<String> = conn\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m___________________________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m217\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .zrange(&key, start, stop).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `AsyncCommands` which provides `zrange` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use redis::AsyncCommands;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `lrange` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m217\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            .\u001b[0m\u001b[0m\u001b[38;5;10mlrange\u001b[0m\u001b[0m(&key, start, stop).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `into_pubsub` found for struct `ConnectionManager` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":945,"byte_end":956,"line_start":33,"line_end":33,"column_start":31,"column_end":42,"is_primary":true,"text":[{"text":"        let mut pubsub = conn.into_pubsub();","highlight_start":31,"highlight_end":42}],"label":"method not found in `ConnectionManager`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `into_pubsub` found for struct `ConnectionManager` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pubsub.rs:33:31\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut pubsub = conn.into_pubsub();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `ConnectionManager`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `into_pubsub` found for struct `ConnectionManager` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":1329,"byte_end":1340,"line_start":44,"line_end":44,"column_start":31,"column_end":42,"is_primary":true,"text":[{"text":"        let mut pubsub = conn.into_pubsub();","highlight_start":31,"highlight_end":42}],"label":"method not found in `ConnectionManager`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `into_pubsub` found for struct `ConnectionManager` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pubsub.rs:44:31\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut pubsub = conn.into_pubsub();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `ConnectionManager`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `unsubscribe_all` found for mutable reference `&mut redis::aio::PubSub` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":2017,"byte_end":2032,"line_start":65,"line_end":65,"column_start":20,"column_end":35,"is_primary":true,"text":[{"text":"            pubsub.unsubscribe_all().await.map_err(|e| RedisError::PubSub(e.to_string()))?;","highlight_start":20,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `unsubscribe` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/aio/connection.rs","byte_start":9402,"byte_end":9484,"line_start":287,"line_end":287,"column_start":5,"column_end":87,"is_primary":true,"text":[{"text":"    pub async fn unsubscribe<T: ToRedisArgs>(&mut self, channel: T) -> RedisResult<()> {","highlight_start":5,"highlight_end":87}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `unsubscribe_all` found for mutable reference `&mut redis::aio::PubSub` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pubsub.rs:65:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            pubsub.unsubscribe_all().await.map_err(|e| RedisError::PubSub(e.to_string()))?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `unsubscribe` with a similar name, but with different arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/aio/connection.rs:287:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m287\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn unsubscribe<T: ToRedisArgs>(&mut self, channel: T) -> RedisResult<()> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":2165,"byte_end":2241,"line_start":71,"line_end":71,"column_start":5,"column_end":81,"is_primary":true,"text":[{"text":"    pub async fn publish(&self, channel: &str, message: &str) -> RedisResult<()> {","highlight_start":5,"highlight_end":81}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":2321,"byte_end":2328,"line_start":73,"line_end":73,"column_start":14,"column_end":21,"is_primary":true,"text":[{"text":"        conn.publish(channel, message).await.map_err(|e| RedisError::PubSub(e.to_string()))?;","highlight_start":14,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pubsub.rs:71:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn publish(&self, channel: &str, message: &str) -> RedisResult<()> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pubsub.rs:73:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        conn.publish(channel, message).await.map_err(|e| RedisError::PubSub(e.to_string()))?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `next` found for opaque type `impl futures_core::stream::Stream<Item = Msg> + '_` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":2890,"byte_end":2894,"line_start":87,"line_end":87,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"                while let Some(msg) = stream.next().await {","highlight_start":46,"highlight_end":50}],"label":"method not found in `impl Stream<Item = Msg>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.31/src/stream/stream/mod.rs","byte_start":8995,"byte_end":8999,"line_start":273,"line_end":273,"column_start":8,"column_end":12,"is_primary":false,"text":[{"text":"    fn next(&mut self) -> Next<'_, Self>","highlight_start":8,"highlight_end":12}],"label":"the method is available for `impl futures_core::stream::Stream<Item = Msg> + '_` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `StreamExt` which provides `next` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use redis::{ AsyncCommands, aio::ConnectionManager };","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use futures_util::stream::stream::StreamExt;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `next` found for opaque type `impl futures_core::stream::Stream<Item = Msg> + '_` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pubsub.rs:87:46\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                while let Some(msg) = stream.next().await {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `impl Stream<Item = Msg>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.31/src/stream/stream/mod.rs:273:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m273\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn next(&mut self) -> Next<'_, Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `impl futures_core::stream::Stream<Item = Msg> + '_` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `StreamExt` which provides `next` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use futures_util::stream::stream::StreamExt;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":4058,"byte_end":4065,"line_start":122,"line_end":122,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"PUBSUB\").arg(\"CHANNELS\");","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":4058,"byte_end":4062,"line_start":122,"line_end":122,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"PUBSUB\").arg(\"CHANNELS\");","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pubsub.rs:122:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m122\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"PUBSUB\").arg(\"CHANNELS\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_mut)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"temporary value dropped while borrowed","code":{"code":"E0716","explanation":"A temporary value is being dropped while a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\na call to a function, and not the name of a variable, this creates a\n**temporary** -- that temporary stores the return value from `foo()` so that it\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\nthe following, which uses an explicit temporary variable.\n\nErroneous code example:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed) according\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\nstatement -- in this case, after the `let p`. This is illustrated in the example\nabove by showing that `tmp` would be freed as we exit the block.\n\nTo fix this problem, you need to create a local variable to store the value in\nrather than relying on a temporary. For example, you might change the original\nprogram to the following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage that will last\nuntil the end of the enclosing block (when `value` goes out of scope). When we\nborrow `&value`, we are borrowing a local variable that already exists, and\nhence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing statement. In\nsimple cases where the `&` expression is immediately stored into a variable, the\ncompiler will automatically extend the lifetime of the temporary until the end\nof the enclosing block. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\ninto a variable, the temporary will not be dropped until the end of the\nenclosing block. Similar rules apply when temporaries are stored into aggregate\nstructures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/pubsub.rs","byte_start":4068,"byte_end":4088,"line_start":122,"line_end":122,"column_start":23,"column_end":43,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"PUBSUB\").arg(\"CHANNELS\");","highlight_start":23,"highlight_end":43}],"label":"creates a temporary value which is freed while still in use","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/pubsub.rs","byte_start":4104,"byte_end":4105,"line_start":122,"line_end":122,"column_start":59,"column_end":60,"is_primary":false,"text":[{"text":"        let mut cmd = redis::cmd(\"PUBSUB\").arg(\"CHANNELS\");","highlight_start":59,"highlight_end":60}],"label":"temporary value is freed at the end of this statement","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/pubsub.rs","byte_start":4160,"byte_end":4163,"line_start":125,"line_end":125,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            cmd.arg(pattern);","highlight_start":13,"highlight_end":16}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to create a longer lived value","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0716]\u001b[0m\u001b[0m\u001b[1m: temporary value dropped while borrowed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pubsub.rs:122:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m122\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"PUBSUB\").arg(\"CHANNELS\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtemporary value is freed at the end of this statement\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcreates a temporary value which is freed while still in use\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m125\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            cmd.arg(pattern);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow later used here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using a `let` binding to create a longer lived value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `dbx_core::Value: FromRedisValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates/redis/src/script.rs","byte_start":1571,"byte_end":1582,"line_start":52,"line_end":52,"column_start":53,"column_end":64,"is_primary":true,"text":[{"text":"        let result: redis::RedisResult<Value> = cmd.query_async(&mut conn).await;","highlight_start":53,"highlight_end":64}],"label":"the trait `FromRedisValue` is not implemented for `dbx_core::Value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromRedisValue`:\n  ()\n  (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T10, T11, T12)\n  (T11, T12)\n  (T12,)\n  (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T4, T5, T6, T7, T8, T9, T10, T11, T12)\nand 44 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Cmd::query_async`","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/cmd.rs","byte_start":12960,"byte_end":12974,"line_start":429,"line_end":429,"column_start":36,"column_end":50,"is_primary":true,"text":[{"text":"    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>","highlight_start":36,"highlight_end":50}],"label":"required by this bound in `Cmd::query_async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `dbx_core::Value: FromRedisValue` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/script.rs:52:53\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let result: redis::RedisResult<Value> = cmd.query_async(&mut conn).await;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `FromRedisValue` is not implemented for `dbx_core::Value`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `FromRedisValue`:\u001b[0m\n\u001b[0m              ()\u001b[0m\n\u001b[0m              (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T10, T11, T12)\u001b[0m\n\u001b[0m              (T11, T12)\u001b[0m\n\u001b[0m              (T12,)\u001b[0m\n\u001b[0m              (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m            and 44 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Cmd::query_async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/cmd.rs:429:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m429\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Cmd::query_async`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `dbx_core::Value: FromRedisValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates/redis/src/script.rs","byte_start":2231,"byte_end":2242,"line_start":68,"line_end":68,"column_start":25,"column_end":36,"is_primary":true,"text":[{"text":"                    cmd.query_async(&mut conn).await.map_err(|e| RedisError::Script(e.to_string()))","highlight_start":25,"highlight_end":36}],"label":"the trait `FromRedisValue` is not implemented for `dbx_core::Value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromRedisValue`:\n  ()\n  (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T10, T11, T12)\n  (T11, T12)\n  (T12,)\n  (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T4, T5, T6, T7, T8, T9, T10, T11, T12)\nand 44 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Cmd::query_async`","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/cmd.rs","byte_start":12960,"byte_end":12974,"line_start":429,"line_end":429,"column_start":36,"column_end":50,"is_primary":true,"text":[{"text":"    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>","highlight_start":36,"highlight_end":50}],"label":"required by this bound in `Cmd::query_async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `dbx_core::Value: FromRedisValue` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/script.rs:68:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    cmd.query_async(&mut conn).await.map_err(|e| RedisError::Script(e.to_string()))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `FromRedisValue` is not implemented for `dbx_core::Value`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `FromRedisValue`:\u001b[0m\n\u001b[0m              ()\u001b[0m\n\u001b[0m              (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T10, T11, T12)\u001b[0m\n\u001b[0m              (T11, T12)\u001b[0m\n\u001b[0m              (T12,)\u001b[0m\n\u001b[0m              (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m            and 44 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Cmd::query_async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/cmd.rs:429:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m429\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Cmd::query_async`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `dbx_core::Value: FromRedisValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates/redis/src/script.rs","byte_start":2935,"byte_end":2946,"line_start":89,"line_end":89,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"        cmd.query_async(&mut conn).await.map_err(|e| RedisError::Script(e.to_string()))","highlight_start":13,"highlight_end":24}],"label":"the trait `FromRedisValue` is not implemented for `dbx_core::Value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromRedisValue`:\n  ()\n  (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T10, T11, T12)\n  (T11, T12)\n  (T12,)\n  (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T4, T5, T6, T7, T8, T9, T10, T11, T12)\nand 44 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Cmd::query_async`","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/cmd.rs","byte_start":12960,"byte_end":12974,"line_start":429,"line_end":429,"column_start":36,"column_end":50,"is_primary":true,"text":[{"text":"    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>","highlight_start":36,"highlight_end":50}],"label":"required by this bound in `Cmd::query_async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `dbx_core::Value: FromRedisValue` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/script.rs:89:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        cmd.query_async(&mut conn).await.map_err(|e| RedisError::Script(e.to_string()))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `FromRedisValue` is not implemented for `dbx_core::Value`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `FromRedisValue`:\u001b[0m\n\u001b[0m              ()\u001b[0m\n\u001b[0m              (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T10, T11, T12)\u001b[0m\n\u001b[0m              (T11, T12)\u001b[0m\n\u001b[0m              (T12,)\u001b[0m\n\u001b[0m              (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m            and 44 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Cmd::query_async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/cmd.rs:429:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m429\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Cmd::query_async`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/script.rs","byte_start":3532,"byte_end":3576,"line_start":106,"line_end":106,"column_start":5,"column_end":49,"is_primary":true,"text":[{"text":"    pub async fn flush(&self) -> RedisResult<()> {","highlight_start":5,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/script.rs","byte_start":3724,"byte_end":3735,"line_start":111,"line_end":111,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut conn).await","highlight_start":14,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/script.rs:106:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn flush(&self) -> RedisResult<()> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/script.rs:111:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut conn).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/script.rs","byte_start":3874,"byte_end":3917,"line_start":117,"line_end":117,"column_start":5,"column_end":48,"is_primary":true,"text":[{"text":"    pub async fn kill(&self) -> RedisResult<()> {","highlight_start":5,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/script.rs","byte_start":4064,"byte_end":4075,"line_start":122,"line_end":122,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut conn).await","highlight_start":14,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/script.rs:117:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m117\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn kill(&self) -> RedisResult<()> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/script.rs:122:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m122\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut conn).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `dbx_core::Value: FromRedisValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates/redis/src/pipeline.rs","byte_start":1218,"byte_end":1229,"line_start":41,"line_end":41,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut conn).await","highlight_start":14,"highlight_end":25}],"label":"the trait `FromRedisValue` is not implemented for `dbx_core::Value`, which is required by `Vec<dbx_core::Value>: FromRedisValue`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromRedisValue`:\n  ()\n  (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T10, T11, T12)\n  (T11, T12)\n  (T12,)\n  (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T4, T5, T6, T7, T8, T9, T10, T11, T12)\nand 44 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Vec<dbx_core::Value>` to implement `FromRedisValue`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Pipeline::query_async`","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/pipeline.rs","byte_start":6323,"byte_end":6337,"line_start":176,"line_end":176,"column_start":36,"column_end":50,"is_primary":true,"text":[{"text":"    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>","highlight_start":36,"highlight_end":50}],"label":"required by this bound in `Pipeline::query_async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `dbx_core::Value: FromRedisValue` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/pipeline.rs:41:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut conn).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `FromRedisValue` is not implemented for `dbx_core::Value`, which is required by `Vec<dbx_core::Value>: FromRedisValue`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `FromRedisValue`:\u001b[0m\n\u001b[0m              ()\u001b[0m\n\u001b[0m              (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T10, T11, T12)\u001b[0m\n\u001b[0m              (T11, T12)\u001b[0m\n\u001b[0m              (T12,)\u001b[0m\n\u001b[0m              (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m            and 44 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `Vec<dbx_core::Value>` to implement `FromRedisValue`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Pipeline::query_async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/pipeline.rs:176:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m176\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Pipeline::query_async`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":800,"byte_end":807,"line_start":28,"line_end":28,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XADD\").arg(key).arg(\"*\");","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":800,"byte_end":804,"line_start":28,"line_end":28,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XADD\").arg(key).arg(\"*\");","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:28:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"XADD\").arg(key).arg(\"*\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"temporary value dropped while borrowed","code":{"code":"E0716","explanation":"A temporary value is being dropped while a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\na call to a function, and not the name of a variable, this creates a\n**temporary** -- that temporary stores the return value from `foo()` so that it\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\nthe following, which uses an explicit temporary variable.\n\nErroneous code example:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed) according\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\nstatement -- in this case, after the `let p`. This is illustrated in the example\nabove by showing that `tmp` would be freed as we exit the block.\n\nTo fix this problem, you need to create a local variable to store the value in\nrather than relying on a temporary. For example, you might change the original\nprogram to the following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage that will last\nuntil the end of the enclosing block (when `value` goes out of scope). When we\nborrow `&value`, we are borrowing a local variable that already exists, and\nhence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing statement. In\nsimple cases where the `&` expression is immediately stored into a variable, the\ncompiler will automatically extend the lifetime of the temporary until the end\nof the enclosing block. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\ninto a variable, the temporary will not be dropped until the end of the\nenclosing block. Similar rules apply when temporaries are stored into aggregate\nstructures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":810,"byte_end":828,"line_start":28,"line_end":28,"column_start":23,"column_end":41,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XADD\").arg(key).arg(\"*\");","highlight_start":23,"highlight_end":41}],"label":"creates a temporary value which is freed while still in use","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":846,"byte_end":847,"line_start":28,"line_end":28,"column_start":59,"column_end":60,"is_primary":false,"text":[{"text":"        let mut cmd = redis::cmd(\"XADD\").arg(key).arg(\"*\");","highlight_start":59,"highlight_end":60}],"label":"temporary value is freed at the end of this statement","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":900,"byte_end":903,"line_start":31,"line_end":31,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            cmd.arg(field).arg(value);","highlight_start":13,"highlight_end":16}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to create a longer lived value","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0716]\u001b[0m\u001b[0m\u001b[1m: temporary value dropped while borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:28:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"XADD\").arg(key).arg(\"*\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtemporary value is freed at the end of this statement\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcreates a temporary value which is freed while still in use\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            cmd.arg(field).arg(value);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow later used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using a `let` binding to create a longer lived value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":1359,"byte_end":1366,"line_start":49,"line_end":49,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        let mut cmd = redis","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":1359,"byte_end":1363,"line_start":49,"line_end":49,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut cmd = redis","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:49:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m49\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"temporary value dropped while borrowed","code":{"code":"E0716","explanation":"A temporary value is being dropped while a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\na call to a function, and not the name of a variable, this creates a\n**temporary** -- that temporary stores the return value from `foo()` so that it\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\nthe following, which uses an explicit temporary variable.\n\nErroneous code example:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed) according\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\nstatement -- in this case, after the `let p`. This is illustrated in the example\nabove by showing that `tmp` would be freed as we exit the block.\n\nTo fix this problem, you need to create a local variable to store the value in\nrather than relying on a temporary. For example, you might change the original\nprogram to the following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage that will last\nuntil the end of the enclosing block (when `value` goes out of scope). When we\nborrow `&value`, we are borrowing a local variable that already exists, and\nhence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing statement. In\nsimple cases where the `&` expression is immediately stored into a variable, the\ncompiler will automatically extend the lifetime of the temporary until the end\nof the enclosing block. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\ninto a variable, the temporary will not be dropped until the end of the\nenclosing block. Similar rules apply when temporaries are stored into aggregate\nstructures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":1369,"byte_end":1401,"line_start":49,"line_end":50,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"        let mut cmd = redis","highlight_start":23,"highlight_end":28},{"text":"            ::cmd(\"XREAD\")","highlight_start":1,"highlight_end":27}],"label":"creates a temporary value which is freed while still in use","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":1541,"byte_end":1542,"line_start":55,"line_end":55,"column_start":27,"column_end":28,"is_primary":false,"text":[{"text":"            .arg(start_id);","highlight_start":27,"highlight_end":28}],"label":"temporary value is freed at the end of this statement","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":1618,"byte_end":1621,"line_start":57,"line_end":57,"column_start":75,"column_end":78,"is_primary":false,"text":[{"text":"        let result: Vec<(String, Vec<(String, Vec<(String, String)>)>)> = cmd","highlight_start":75,"highlight_end":78}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to create a longer lived value","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0716]\u001b[0m\u001b[0m\u001b[1m: temporary value dropped while borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:49:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m49\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let mut cmd = redis\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m_______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ::cmd(\"XREAD\")\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|__________________________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcreates a temporary value which is freed while still in use\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            .arg(start_id);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtemporary value is freed at the end of this statement\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result: Vec<(String, Vec<(String, Vec<(String, String)>)>)> = cmd\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow later used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using a `let` binding to create a longer lived value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":2430,"byte_end":2437,"line_start":82,"line_end":82,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XREAD\").arg(\"COUNT\").arg(count.unwrap_or(1)).arg(\"STREAMS\");","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":2430,"byte_end":2434,"line_start":82,"line_end":82,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XREAD\").arg(\"COUNT\").arg(count.unwrap_or(1)).arg(\"STREAMS\");","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:82:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"XREAD\").arg(\"COUNT\").arg(count.unwrap_or(1)).arg(\"STREAMS\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"temporary value dropped while borrowed","code":{"code":"E0716","explanation":"A temporary value is being dropped while a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\na call to a function, and not the name of a variable, this creates a\n**temporary** -- that temporary stores the return value from `foo()` so that it\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\nthe following, which uses an explicit temporary variable.\n\nErroneous code example:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed) according\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\nstatement -- in this case, after the `let p`. This is illustrated in the example\nabove by showing that `tmp` would be freed as we exit the block.\n\nTo fix this problem, you need to create a local variable to store the value in\nrather than relying on a temporary. For example, you might change the original\nprogram to the following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage that will last\nuntil the end of the enclosing block (when `value` goes out of scope). When we\nborrow `&value`, we are borrowing a local variable that already exists, and\nhence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing statement. In\nsimple cases where the `&` expression is immediately stored into a variable, the\ncompiler will automatically extend the lifetime of the temporary until the end\nof the enclosing block. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\ninto a variable, the temporary will not be dropped until the end of the\nenclosing block. Similar rules apply when temporaries are stored into aggregate\nstructures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":2440,"byte_end":2459,"line_start":82,"line_end":82,"column_start":23,"column_end":42,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XREAD\").arg(\"COUNT\").arg(count.unwrap_or(1)).arg(\"STREAMS\");","highlight_start":23,"highlight_end":42}],"label":"creates a temporary value which is freed while still in use","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":2511,"byte_end":2512,"line_start":82,"line_end":82,"column_start":94,"column_end":95,"is_primary":false,"text":[{"text":"        let mut cmd = redis::cmd(\"XREAD\").arg(\"COUNT\").arg(count.unwrap_or(1)).arg(\"STREAMS\");","highlight_start":94,"highlight_end":95}],"label":"temporary value is freed at the end of this statement","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":2565,"byte_end":2568,"line_start":85,"line_end":85,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            cmd.arg(key);","highlight_start":13,"highlight_end":16}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to create a longer lived value","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0716]\u001b[0m\u001b[0m\u001b[1m: temporary value dropped while borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:82:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"XREAD\").arg(\"COUNT\").arg(count.unwrap_or(1)).arg(\"STREAMS\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtemporary value is freed at the end of this statement\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcreates a temporary value which is freed while still in use\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m85\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            cmd.arg(key);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow later used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using a `let` binding to create a longer lived value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":4397,"byte_end":4404,"line_start":141,"line_end":141,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XDEL\").arg(key);","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":4397,"byte_end":4401,"line_start":141,"line_end":141,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XDEL\").arg(key);","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:141:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m141\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"XDEL\").arg(key);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"temporary value dropped while borrowed","code":{"code":"E0716","explanation":"A temporary value is being dropped while a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\na call to a function, and not the name of a variable, this creates a\n**temporary** -- that temporary stores the return value from `foo()` so that it\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\nthe following, which uses an explicit temporary variable.\n\nErroneous code example:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed) according\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\nstatement -- in this case, after the `let p`. This is illustrated in the example\nabove by showing that `tmp` would be freed as we exit the block.\n\nTo fix this problem, you need to create a local variable to store the value in\nrather than relying on a temporary. For example, you might change the original\nprogram to the following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage that will last\nuntil the end of the enclosing block (when `value` goes out of scope). When we\nborrow `&value`, we are borrowing a local variable that already exists, and\nhence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing statement. In\nsimple cases where the `&` expression is immediately stored into a variable, the\ncompiler will automatically extend the lifetime of the temporary until the end\nof the enclosing block. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\ninto a variable, the temporary will not be dropped until the end of the\nenclosing block. Similar rules apply when temporaries are stored into aggregate\nstructures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":4407,"byte_end":4425,"line_start":141,"line_end":141,"column_start":23,"column_end":41,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XDEL\").arg(key);","highlight_start":23,"highlight_end":41}],"label":"creates a temporary value which is freed while still in use","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":4434,"byte_end":4435,"line_start":141,"line_end":141,"column_start":50,"column_end":51,"is_primary":false,"text":[{"text":"        let mut cmd = redis::cmd(\"XDEL\").arg(key);","highlight_start":50,"highlight_end":51}],"label":"temporary value is freed at the end of this statement","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":4473,"byte_end":4476,"line_start":144,"line_end":144,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            cmd.arg(id);","highlight_start":13,"highlight_end":16}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to create a longer lived value","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0716]\u001b[0m\u001b[0m\u001b[1m: temporary value dropped while borrowed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:141:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m141\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"XDEL\").arg(key);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtemporary value is freed at the end of this statement\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcreates a temporary value which is freed while still in use\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            cmd.arg(id);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow later used here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using a `let` binding to create a longer lived value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `dbx_core::Value: FromRedisValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":4974,"byte_end":4985,"line_start":161,"line_end":161,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut conn).await","highlight_start":14,"highlight_end":25}],"label":"the trait `FromRedisValue` is not implemented for `dbx_core::Value`, which is required by `HashMap<std::string::String, dbx_core::Value>: FromRedisValue`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromRedisValue`:\n  ()\n  (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T10, T11, T12)\n  (T11, T12)\n  (T12,)\n  (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T4, T5, T6, T7, T8, T9, T10, T11, T12)\nand 44 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `HashMap<std::string::String, dbx_core::Value>` to implement `FromRedisValue`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Cmd::query_async`","code":null,"level":"note","spans":[{"file_name":"/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/cmd.rs","byte_start":12960,"byte_end":12974,"line_start":429,"line_end":429,"column_start":36,"column_end":50,"is_primary":true,"text":[{"text":"    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>","highlight_start":36,"highlight_end":50}],"label":"required by this bound in `Cmd::query_async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `dbx_core::Value: FromRedisValue` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:161:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m161\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut conn).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `FromRedisValue` is not implemented for `dbx_core::Value`, which is required by `HashMap<std::string::String, dbx_core::Value>: FromRedisValue`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `FromRedisValue`:\u001b[0m\n\u001b[0m              ()\u001b[0m\n\u001b[0m              (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T10, T11, T12)\u001b[0m\n\u001b[0m              (T11, T12)\u001b[0m\n\u001b[0m              (T12,)\u001b[0m\n\u001b[0m              (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m              (T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m            and 44 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `HashMap<std::string::String, dbx_core::Value>` to implement `FromRedisValue`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Cmd::query_async`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/nasimakhtar/.cargo/registry/src/index.crates.io-6f17d22bba15001f/redis-0.24.0/src/cmd.rs:429:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m429\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn query_async<C, T: FromRedisValue>(&self, con: &mut C) -> RedisResult<T>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Cmd::query_async`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":5126,"byte_end":5217,"line_start":168,"line_end":168,"column_start":5,"column_end":96,"is_primary":true,"text":[{"text":"    pub async fn create_group(&self, key: &str, group: &str, start_id: &str) -> RedisResult<()> {","highlight_start":5,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":5468,"byte_end":5479,"line_start":177,"line_end":177,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut conn).await","highlight_start":14,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:168:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn create_group(&self, key: &str, group: &str, start_id: &str) -> RedisResult<()> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:177:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut conn).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":5882,"byte_end":5889,"line_start":192,"line_end":192,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        let mut cmd = redis","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":5882,"byte_end":5886,"line_start":192,"line_end":192,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut cmd = redis","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:192:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"temporary value dropped while borrowed","code":{"code":"E0716","explanation":"A temporary value is being dropped while a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\na call to a function, and not the name of a variable, this creates a\n**temporary** -- that temporary stores the return value from `foo()` so that it\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\nthe following, which uses an explicit temporary variable.\n\nErroneous code example:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed) according\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\nstatement -- in this case, after the `let p`. This is illustrated in the example\nabove by showing that `tmp` would be freed as we exit the block.\n\nTo fix this problem, you need to create a local variable to store the value in\nrather than relying on a temporary. For example, you might change the original\nprogram to the following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage that will last\nuntil the end of the enclosing block (when `value` goes out of scope). When we\nborrow `&value`, we are borrowing a local variable that already exists, and\nhence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing statement. In\nsimple cases where the `&` expression is immediately stored into a variable, the\ncompiler will automatically extend the lifetime of the temporary until the end\nof the enclosing block. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\ninto a variable, the temporary will not be dropped until the end of the\nenclosing block. Similar rules apply when temporaries are stored into aggregate\nstructures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":5892,"byte_end":5929,"line_start":192,"line_end":193,"column_start":23,"column_end":32,"is_primary":true,"text":[{"text":"        let mut cmd = redis","highlight_start":23,"highlight_end":28},{"text":"            ::cmd(\"XREADGROUP\")","highlight_start":1,"highlight_end":32}],"label":"creates a temporary value which is freed while still in use","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":6141,"byte_end":6142,"line_start":201,"line_end":201,"column_start":22,"column_end":23,"is_primary":false,"text":[{"text":"            .arg(\">\");","highlight_start":22,"highlight_end":23}],"label":"temporary value is freed at the end of this statement","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":6218,"byte_end":6221,"line_start":203,"line_end":203,"column_start":75,"column_end":78,"is_primary":false,"text":[{"text":"        let result: Vec<(String, Vec<(String, Vec<(String, String)>)>)> = cmd","highlight_start":75,"highlight_end":78}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to create a longer lived value","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0716]\u001b[0m\u001b[0m\u001b[1m: temporary value dropped while borrowed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:192:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let mut cmd = redis\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m_______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ::cmd(\"XREADGROUP\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_______________________________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcreates a temporary value which is freed while still in use\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            .arg(\">\");\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtemporary value is freed at the end of this statement\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m203\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result: Vec<(String, Vec<(String, Vec<(String, String)>)>)> = cmd\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow later used here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using a `let` binding to create a longer lived value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":6952,"byte_end":6959,"line_start":224,"line_end":224,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XACK\").arg(key).arg(group);","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":6952,"byte_end":6956,"line_start":224,"line_end":224,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XACK\").arg(key).arg(group);","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:224:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"XACK\").arg(key).arg(group);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"temporary value dropped while borrowed","code":{"code":"E0716","explanation":"A temporary value is being dropped while a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\na call to a function, and not the name of a variable, this creates a\n**temporary** -- that temporary stores the return value from `foo()` so that it\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\nthe following, which uses an explicit temporary variable.\n\nErroneous code example:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed) according\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\nstatement -- in this case, after the `let p`. This is illustrated in the example\nabove by showing that `tmp` would be freed as we exit the block.\n\nTo fix this problem, you need to create a local variable to store the value in\nrather than relying on a temporary. For example, you might change the original\nprogram to the following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage that will last\nuntil the end of the enclosing block (when `value` goes out of scope). When we\nborrow `&value`, we are borrowing a local variable that already exists, and\nhence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing statement. In\nsimple cases where the `&` expression is immediately stored into a variable, the\ncompiler will automatically extend the lifetime of the temporary until the end\nof the enclosing block. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\ninto a variable, the temporary will not be dropped until the end of the\nenclosing block. Similar rules apply when temporaries are stored into aggregate\nstructures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/stream.rs","byte_start":6962,"byte_end":6980,"line_start":224,"line_end":224,"column_start":23,"column_end":41,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"XACK\").arg(key).arg(group);","highlight_start":23,"highlight_end":41}],"label":"creates a temporary value which is freed while still in use","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":7000,"byte_end":7001,"line_start":224,"line_end":224,"column_start":61,"column_end":62,"is_primary":false,"text":[{"text":"        let mut cmd = redis::cmd(\"XACK\").arg(key).arg(group);","highlight_start":61,"highlight_end":62}],"label":"temporary value is freed at the end of this statement","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/stream.rs","byte_start":7039,"byte_end":7042,"line_start":227,"line_end":227,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            cmd.arg(id);","highlight_start":13,"highlight_end":16}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to create a longer lived value","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0716]\u001b[0m\u001b[0m\u001b[1m: temporary value dropped while borrowed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/stream.rs:224:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"XACK\").arg(key).arg(group);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtemporary value is freed at the end of this statement\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcreates a temporary value which is freed while still in use\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m227\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            cmd.arg(id);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow later used here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using a `let` binding to create a longer lived value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":604,"byte_end":611,"line_start":19,"line_end":19,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"PFADD\").arg(key);","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":604,"byte_end":608,"line_start":19,"line_end":19,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"PFADD\").arg(key);","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/hll.rs:19:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"PFADD\").arg(key);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"temporary value dropped while borrowed","code":{"code":"E0716","explanation":"A temporary value is being dropped while a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\na call to a function, and not the name of a variable, this creates a\n**temporary** -- that temporary stores the return value from `foo()` so that it\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\nthe following, which uses an explicit temporary variable.\n\nErroneous code example:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed) according\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\nstatement -- in this case, after the `let p`. This is illustrated in the example\nabove by showing that `tmp` would be freed as we exit the block.\n\nTo fix this problem, you need to create a local variable to store the value in\nrather than relying on a temporary. For example, you might change the original\nprogram to the following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage that will last\nuntil the end of the enclosing block (when `value` goes out of scope). When we\nborrow `&value`, we are borrowing a local variable that already exists, and\nhence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing statement. In\nsimple cases where the `&` expression is immediately stored into a variable, the\ncompiler will automatically extend the lifetime of the temporary until the end\nof the enclosing block. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\ninto a variable, the temporary will not be dropped until the end of the\nenclosing block. Similar rules apply when temporaries are stored into aggregate\nstructures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":614,"byte_end":633,"line_start":19,"line_end":19,"column_start":23,"column_end":42,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"PFADD\").arg(key);","highlight_start":23,"highlight_end":42}],"label":"creates a temporary value which is freed while still in use","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/hll.rs","byte_start":642,"byte_end":643,"line_start":19,"line_end":19,"column_start":51,"column_end":52,"is_primary":false,"text":[{"text":"        let mut cmd = redis::cmd(\"PFADD\").arg(key);","highlight_start":51,"highlight_end":52}],"label":"temporary value is freed at the end of this statement","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/hll.rs","byte_start":691,"byte_end":694,"line_start":22,"line_end":22,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            cmd.arg(element);","highlight_start":13,"highlight_end":16}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to create a longer lived value","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0716]\u001b[0m\u001b[0m\u001b[1m: temporary value dropped while borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/hll.rs:19:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"PFADD\").arg(key);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtemporary value is freed at the end of this statement\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcreates a temporary value which is freed while still in use\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            cmd.arg(element);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow later used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using a `let` binding to create a longer lived value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":1835,"byte_end":1917,"line_start":61,"line_end":61,"column_start":5,"column_end":87,"is_primary":true,"text":[{"text":"    pub async fn merge(&self, dest_key: &str, source_keys: &[&str]) -> RedisResult<()> {","highlight_start":5,"highlight_end":87}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":2126,"byte_end":2137,"line_start":69,"line_end":69,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"        cmd.query_async(&mut conn).await.map_err(|e| RedisError::HyperLogLog(e.to_string()))?;","highlight_start":13,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/hll.rs:61:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn merge(&self, dest_key: &str, source_keys: &[&str]) -> RedisResult<()> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/hll.rs:69:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        cmd.query_async(&mut conn).await.map_err(|e| RedisError::HyperLogLog(e.to_string()))?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":1996,"byte_end":2003,"line_start":63,"line_end":63,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"PFMERGE\").arg(dest_key);","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":1996,"byte_end":2000,"line_start":63,"line_end":63,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"PFMERGE\").arg(dest_key);","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/hll.rs:63:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"PFMERGE\").arg(dest_key);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"temporary value dropped while borrowed","code":{"code":"E0716","explanation":"A temporary value is being dropped while a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression `foo()`. As `foo()` is\na call to a function, and not the name of a variable, this creates a\n**temporary** -- that temporary stores the return value from `foo()` so that it\ncan be borrowed. You could imagine that `let p = bar(&foo());` is equivalent to\nthe following, which uses an explicit temporary variable.\n\nErroneous code example:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp) // error: `tmp` does not live long enough\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed) according\nto fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing\nstatement -- in this case, after the `let p`. This is illustrated in the example\nabove by showing that `tmp` would be freed as we exit the block.\n\nTo fix this problem, you need to create a local variable to store the value in\nrather than relying on a temporary. For example, you might change the original\nprogram to the following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage that will last\nuntil the end of the enclosing block (when `value` goes out of scope). When we\nborrow `&value`, we are borrowing a local variable that already exists, and\nhence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing statement. In\nsimple cases where the `&` expression is immediately stored into a variable, the\ncompiler will automatically extend the lifetime of the temporary until the end\nof the enclosing block. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned directly\ninto a variable, the temporary will not be dropped until the end of the\nenclosing block. Similar rules apply when temporaries are stored into aggregate\nstructures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n"},"level":"error","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":2006,"byte_end":2027,"line_start":63,"line_end":63,"column_start":23,"column_end":44,"is_primary":true,"text":[{"text":"        let mut cmd = redis::cmd(\"PFMERGE\").arg(dest_key);","highlight_start":23,"highlight_end":44}],"label":"creates a temporary value which is freed while still in use","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/hll.rs","byte_start":2041,"byte_end":2042,"line_start":63,"line_end":63,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        let mut cmd = redis::cmd(\"PFMERGE\").arg(dest_key);","highlight_start":58,"highlight_end":59}],"label":"temporary value is freed at the end of this statement","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/redis/src/hll.rs","byte_start":2089,"byte_end":2092,"line_start":66,"line_end":66,"column_start":13,"column_end":16,"is_primary":false,"text":[{"text":"            cmd.arg(key);","highlight_start":13,"highlight_end":16}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using a `let` binding to create a longer lived value","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0716]\u001b[0m\u001b[0m\u001b[1m: temporary value dropped while borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/hll.rs:63:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut cmd = redis::cmd(\"PFMERGE\").arg(dest_key);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtemporary value is freed at the end of this statement\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcreates a temporary value which is freed while still in use\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            cmd.arg(key);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow later used here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using a `let` binding to create a longer lived value\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"warning","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":2694,"byte_end":2760,"line_start":87,"line_end":87,"column_start":5,"column_end":71,"is_primary":true,"text":[{"text":"    pub async fn set(&self, key: &str, data: &[u8]) -> RedisResult<()> {","highlight_start":5,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"crates/redis/src/hll.rs","byte_start":2924,"byte_end":2935,"line_start":93,"line_end":93,"column_start":14,"column_end":25,"is_primary":true,"text":[{"text":"            .query_async(&mut conn).await","highlight_start":14,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/hll.rs:87:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub async fn set(&self, key: &str, data: &[u8]) -> RedisResult<()> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: specify the types explicitly\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/redis/src/hll.rs:93:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .query_async(&mut conn).await\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 53 previous errors; 30 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 53 previous errors; 30 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0255, E0277, E0432, E0599, E0603, E0716.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0255, E0277, E0432, E0599, E0603, E0716.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0255`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0255`.\u001b[0m\n"}
